[
  {
    "title": "Make Costs of Paths Equal in a Binary Tree",
    "description": "You are given an integer n representing the number of nodes in a perfect binary tree consisting of nodes numbered from 1 to n. The root of the tree is node 1 and each node i in the tree has two children where the left child is the node 2 * i and the right child is 2 * i + 1.\nEach node in the tree also has a cost represented by a given 0-indexed integer array cost of size n where cost[i] is the cost of node i + 1. You are allowed to increment the cost of any node by 1 any number of times.\nReturn the minimum number of increments you need to make the cost of paths from the root to each leaf node equal.\nNote:\n\nA perfect binary tree is a tree where each node, except the leaf nodes, has exactly 2 children.\nThe cost of a path is the sum of costs of nodes in the path.\n\n \nExample 1:\n\nInput: n = 7, cost = [1,5,2,2,3,3,1]\nOutput: 6\nExplanation: We can do the following increments:\n- Increase the cost of node 4 one time.\n- Increase the cost of node 3 three times.\n- Increase the cost of node 7 two times.\nEach path from the root to a leaf will have a total cost of 9.\nThe total increments we did is 1 + 3 + 2 = 6.\nIt can be shown that this is the minimum answer we can achieve.\n\nExample 2:\n\nInput: n = 3, cost = [5,3,3]\nOutput: 0\nExplanation: The two paths already have equal total costs, so no increments are needed.\n\n \nConstraints:\n\n3 <= n <= 105\nn + 1 is a power of 2\ncost.length == n\n1 <= cost[i] <= 104",
    "examples": [
      {
        "input": "Input: n = 7, cost = [1,5,2,2,3,3,1]",
        "output": "Output: 6",
        "explanation": "Explanation: We can do the following increments:"
      },
      {
        "input": "Input: n = 3, cost = [5,3,3]",
        "output": "Output: 0",
        "explanation": "Explanation: The two paths already have equal total costs, so no increments are needed."
      }
    ],
    "topics": [
      "Array",
      "Dynamic Programming",
      "Greedy",
      "Tree",
      "Binary Tree"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Number of Adjacent Elements With the Same Color",
    "description": "There is a 0-indexed array nums of length n. Initially, all elements are uncolored (has a value of 0).\nYou are given a 2D integer array queries where queries[i] = [indexi, colori].\nFor each query, you color the index indexi with the color colori in the array nums.\nReturn an array answer of the same length as queries where answer[i] is the number of adjacent elements with the same color after the ith query.\nMore formally, answer[i] is the number of indices j, such that 0 <= j < n - 1 and nums[j] == nums[j + 1] and nums[j] != 0 after the ith query.\n \nExample 1:\nInput: n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]\nOutput: [0,1,1,0,2]\nExplanation: Initially array nums = [0,0,0,0], where 0 denotes uncolored elements of the array.\n- After the 1st query nums = [2,0,0,0]. The count of adjacent elements with the same color is 0.\n- After the 2nd query nums = [2,2,0,0]. The count of adjacent elements with the same color is 1.\n- After the 3rd query nums = [2,2,0,1]. The count of adjacent elements with the same color is 1.\n- After the 4th query nums = [2,1,0,1]. The count of adjacent elements with the same color is 0.\n- After the 5th query nums = [2,1,1,1]. The count of adjacent elements with the same color is 2.\n\nExample 2:\nInput: n = 1, queries = [[0,100000]]\nOutput: [0]\nExplanation: Initially array nums = [0], where 0 denotes uncolored elements of the array.\n- After the 1st query nums = [100000]. The count of adjacent elements with the same color is 0.\n\n \nConstraints:\n\n1 <= n <= 105\n1 <= queries.length <= 105\nqueries[i].length == 2\n0 <= indexi <= n - 1\n1 <=  colori <= 105",
    "examples": [
      {
        "input": "Input: n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]",
        "output": "Output: [0,1,1,0,2]",
        "explanation": "Explanation: Initially array nums = [0,0,0,0], where 0 denotes uncolored elements of the array."
      },
      {
        "input": "Input: n = 1, queries = [[0,100000]]",
        "output": "Output: [0]",
        "explanation": "Explanation: Initially array nums = [0], where 0 denotes uncolored elements of the array."
      }
    ],
    "topics": [
      "Array"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Frequency Tracker",
    "description": "Design a data structure that keeps track of the values in it and answers some queries regarding their frequencies.\nImplement the FrequencyTracker class.\n\nFrequencyTracker(): Initializes the FrequencyTracker object with an empty array initially.\nvoid add(int number): Adds number to the data structure.\nvoid deleteOne(int number): Deletes one occurence of number from the data structure. The data structure may not contain number, and in this case nothing is deleted.\nbool hasFrequency(int frequency): Returns true if there is a number in the data structure that occurs frequency number of times, otherwise, it returns false.\n\n \nExample 1:\nInput\n[\"FrequencyTracker\", \"add\", \"add\", \"hasFrequency\"]\n[[], [3], [3], [2]]\nOutput\n[null, null, null, true]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.add(3); // The data structure now contains [3, 3]\nfrequencyTracker.hasFrequency(2); // Returns true, because 3 occurs twice\n\n\nExample 2:\nInput\n[\"FrequencyTracker\", \"add\", \"deleteOne\", \"hasFrequency\"]\n[[], [1], [1], [1]]\nOutput\n[null, null, null, false]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(1); // The data structure now contains [1]\nfrequencyTracker.deleteOne(1); // The data structure becomes empty []\nfrequencyTracker.hasFrequency(1); // Returns false, because the data structure is empty\n\n\nExample 3:\nInput\n[\"FrequencyTracker\", \"hasFrequency\", \"add\", \"hasFrequency\"]\n[[], [2], [3], [1]]\nOutput\n[null, false, null, true]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.hasFrequency(2); // Returns false, because the data structure is empty\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.hasFrequency(1); // Returns true, because 3 occurs once\n\n\n \nConstraints:\n\n1 <= number <= 105\n1 <= frequency <= 105\nAt most, 2 * 105 calls will be made to add, deleteOne, and hasFrequency in total.",
    "examples": [
      {
        "input": "Input\n[\"FrequencyTracker\", \"add\", \"add\", \"hasFrequency\"]",
        "output": "Output\n[null, null, null, true]",
        "explanation": "Explanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();"
      },
      {
        "input": "Input\n[\"FrequencyTracker\", \"add\", \"deleteOne\", \"hasFrequency\"]",
        "output": "Output\n[null, null, null, false]",
        "explanation": "Explanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();"
      },
      {
        "input": "Input\n[\"FrequencyTracker\", \"hasFrequency\", \"add\", \"hasFrequency\"]",
        "output": "Output\n[null, false, null, true]",
        "explanation": "Explanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();"
      }
    ],
    "topics": [
      "Hash Table",
      "Design"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Find the Distinct Difference Array",
    "description": "You are given a 0-indexed array nums of length n.\nThe distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].\nReturn the distinct difference array of nums.\nNote that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.\n \nExample 1:\nInput: nums = [1,2,3,4,5]\nOutput: [-3,-1,1,3,5]\nExplanation: For index i = 0, there is 1 element in the prefix and 4 distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 3 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 3 - 2 = 1.\nFor index i = 3, there are 4 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 4 - 1 = 3.\nFor index i = 4, there are 5 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.\n\nExample 2:\nInput: nums = [3,2,3,4,2]\nOutput: [-2,-1,0,2,3]\nExplanation: For index i = 0, there is 1 element in the prefix and 3 distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 2 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 2 - 2 = 0.\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\nFor index i = 4, there are 3 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3.\n\n \nConstraints:\n\n1 <= n == nums.length <= 50\n1 <= nums[i] <= 50",
    "examples": [
      {
        "input": "Input: nums = [1,2,3,4,5]",
        "output": "Output: [-3,-1,1,3,5]",
        "explanation": "Explanation: For index i = 0, there is 1 element in the prefix and 4 distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3."
      },
      {
        "input": "Input: nums = [3,2,3,4,2]",
        "output": "Output: [-2,-1,0,2,3]",
        "explanation": "Explanation: For index i = 0, there is 1 element in the prefix and 3 distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2."
      }
    ],
    "topics": [
      "Array",
      "Hash Table"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Maximum Sum With Exactly K Elements ",
    "description": "You are given a 0-indexed integer array nums and an integer k. Your task is to perform the following operation exactly k times in order to maximize your score:\n\nSelect an element m from nums.\nRemove the selected element m from the array.\nAdd a new element with a value of m + 1 to the array.\nIncrease your score by m.\n\nReturn the maximum score you can achieve after performing the operation exactly k times.\n \nExample 1:\nInput: nums = [1,2,3,4,5], k = 3\nOutput: 18\nExplanation: We need to choose exactly 3 elements from nums to maximize the sum.\nFor the first iteration, we choose 5. Then sum is 5 and nums = [1,2,3,4,6]\nFor the second iteration, we choose 6. Then sum is 5 + 6 and nums = [1,2,3,4,7]\nFor the third iteration, we choose 7. Then sum is 5 + 6 + 7 = 18 and nums = [1,2,3,4,8]\nSo, we will return 18.\nIt can be proven, that 18 is the maximum answer that we can achieve.\n\nExample 2:\nInput: nums = [5,5,5], k = 2\nOutput: 11\nExplanation: We need to choose exactly 2 elements from nums to maximize the sum.\nFor the first iteration, we choose 5. Then sum is 5 and nums = [5,5,6]\nFor the second iteration, we choose 6. Then sum is 5 + 6 = 11 and nums = [5,5,7]\nSo, we will return 11.\nIt can be proven, that 11 is the maximum answer that we can achieve.\n\n \nConstraints:\n\n1 <= nums.length <= 100\n1 <= nums[i] <= 100\n1 <= k <= 100",
    "examples": [
      {
        "input": "Input: nums = [1,2,3,4,5], k = 3",
        "output": "Output: 18",
        "explanation": "Explanation: We need to choose exactly 3 elements from nums to maximize the sum."
      },
      {
        "input": "Input: nums = [5,5,5], k = 2",
        "output": "Output: 11",
        "explanation": "Explanation: We need to choose exactly 2 elements from nums to maximize the sum."
      }
    ],
    "topics": [
      "Array",
      "Greedy"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Find the Prefix Common Array of Two Arrays",
    "description": "You are given two 0-indexed integer permutations A and B of length n.\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\nReturn the prefix common array of A and B.\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\n \nExample 1:\nInput: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]\nExplanation: At i = 0: no number is common, so C[0] = 0.\nAt i = 1: 1 and 3 are common in A and B, so C[1] = 2.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\nAt i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.\n\nExample 2:\nInput: A = [2,3,1], B = [3,1,2]\nOutput: [0,1,3]\nExplanation: At i = 0: no number is common, so C[0] = 0.\nAt i = 1: only 3 is common in A and B, so C[1] = 1.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\n\n \nConstraints:\n\n1 <= A.length == B.length == n <= 50\n1 <= A[i], B[i] <= n\nIt is guaranteed that A and B are both a permutation of n integers.",
    "examples": [
      {
        "input": "Input: A = [1,3,2,4], B = [3,1,2,4]",
        "output": "Output: [0,2,3,4]",
        "explanation": "Explanation: At i = 0: no number is common, so C[0] = 0."
      },
      {
        "input": "Input: A = [2,3,1], B = [3,1,2]",
        "output": "Output: [0,1,3]",
        "explanation": "Explanation: At i = 0: no number is common, so C[0] = 0."
      }
    ],
    "topics": [
      "Array",
      "Hash Table"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Make Array Empty",
    "description": "You are given an integer array nums containing distinct numbers, and you can perform the following operations until the array is empty:\n\nIf the first element has the smallest value, remove it\nOtherwise, put the first element at the end of the array.\n\nReturn an integer denoting the number of operations it takes to make nums empty.\n \nExample 1:\nInput: nums = [3,4,-1]\nOutput: 5\n\nOperationArray1[4, -1, 3]2[-1, 3, 4]3[3, 4]4[4]5[]\nExample 2:\nInput: nums = [1,2,4,3]\nOutput: 5\n\nOperationArray1[2, 4, 3]2[4, 3]3[3, 4]4[4]5[]\nExample 3:\nInput: nums = [1,2,3]\nOutput: 3\n\nOperationArray1[2, 3]2[3]3[]\n \nConstraints:\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109\nAll values in nums are distinct.",
    "examples": [
      {
        "input": "Input: nums = [3,4,-1]",
        "output": "Output: 5",
        "explanation": ""
      },
      {
        "input": "Input: nums = [1,2,4,3]",
        "output": "Output: 5",
        "explanation": ""
      },
      {
        "input": "Input: nums = [1,2,3]",
        "output": "Output: 3",
        "explanation": ""
      }
    ],
    "topics": [
      "Array",
      "Binary Search",
      "Greedy",
      "Binary Indexed Tree",
      "Segment Tree",
      "Sorting",
      "Ordered Set"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Maximum Number of Fish in a Grid",
    "description": "You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents:\n\nA land cell if grid[r][c] = 0, or\nA water cell containing grid[r][c] fish, if grid[r][c] > 0.\n\nA fisher can start at any water cell (r, c) and can do the following operations any number of times:\n\nCatch all the fish at cell (r, c), or\nMove to any adjacent water cell.\n\nReturn the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists.\nAn adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.\n \nExample 1:\n\nInput: grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]\nOutput: 7\nExplanation: The fisher can start at cell (1,3) and collect 3 fish, then move to cell (2,3) and collect 4 fish.\n\nExample 2:\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]\nOutput: 1\nExplanation: The fisher can start at cells (0,0) or (3,3) and collect a single fish. \n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 10\n0 <= grid[i][j] <= 10",
    "examples": [
      {
        "input": "Input: grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]",
        "output": "Output: 7",
        "explanation": "Explanation: The fisher can start at cell (1,3) and collect 3 fish, then move to cell (2,3) and collect 4 fish."
      },
      {
        "input": "Input: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]",
        "output": "Output: 1",
        "explanation": "Explanation: The fisher can start at cells (0,0) or (3,3) and collect a single fish. "
      }
    ],
    "topics": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Matrix"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Minimum Number of Operations to Make All Array Elements Equal to 1",
    "description": "You are given a 0-indexed array nums consisiting of positive integers. You can do the following operation on the array any number of times:\n\nSelect an index i such that 0 <= i < n - 1 and replace either of nums[i] or nums[i+1] with their gcd value.\n\nReturn the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1.\nThe gcd of two integers is the greatest common divisor of the two integers.\n \nExample 1:\nInput: nums = [2,6,3,4]\nOutput: 4\nExplanation: We can do the following operations:\n- Choose index i = 2 and replace nums[2] with gcd(3,4) = 1. Now we have nums = [2,6,1,4].\n- Choose index i = 1 and replace nums[1] with gcd(6,1) = 1. Now we have nums = [2,1,1,4].\n- Choose index i = 0 and replace nums[0] with gcd(2,1) = 1. Now we have nums = [1,1,1,4].\n- Choose index i = 2 and replace nums[3] with gcd(1,4) = 1. Now we have nums = [1,1,1,1].\n\nExample 2:\nInput: nums = [2,10,6,14]\nOutput: -1\nExplanation: It can be shown that it is impossible to make all the elements equal to 1.\n\n \nConstraints:\n\n2 <= nums.length <= 50\n1 <= nums[i] <= 106\n\n \nFollow-up:\nThe O(n) time complexity solution works, but could you find an O(1) constant time complexity solution?",
    "examples": [
      {
        "input": "Input: nums = [2,6,3,4]",
        "output": "Output: 4",
        "explanation": "Explanation: We can do the following operations:"
      },
      {
        "input": "Input: nums = [2,10,6,14]",
        "output": "Output: -1",
        "explanation": "Explanation: It can be shown that it is impossible to make all the elements equal to 1."
      }
    ],
    "topics": [
      "Array",
      "Math",
      "Number Theory"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Sum Multiples",
    "description": "Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.\nReturn an integer denoting the sum of all numbers in the given range satisfying the constraint.\n \nExample 1:\nInput: n = 7\nOutput: 21\nExplanation: Numbers in the range [1, 7] that are divisible by 3, 5, or 7 are 3, 5, 6, 7. The sum of these numbers is 21.\n\nExample 2:\nInput: n = 10\nOutput: 40\nExplanation: Numbers in the range [1, 10] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9, 10. The sum of these numbers is 40.\n\nExample 3:\nInput: n = 9\nOutput: 30\nExplanation: Numbers in the range [1, 9] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9. The sum of these numbers is 30.\n\n \nConstraints:\n\n1 <= n <= 103",
    "examples": [
      {
        "input": "Input: n = 7",
        "output": "Output: 21",
        "explanation": "Explanation: Numbers in the range [1, 7] that are divisible by 3, 5, or 7 are 3, 5, 6, 7. The sum of these numbers is 21."
      },
      {
        "input": "Input: n = 10",
        "output": "Output: 40",
        "explanation": "Explanation: Numbers in the range [1, 10] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9, 10. The sum of these numbers is 40."
      },
      {
        "input": "Input: n = 9",
        "output": "Output: 30",
        "explanation": "Explanation: Numbers in the range [1, 9] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9. The sum of these numbers is 30."
      }
    ],
    "topics": [
      "Array",
      "Math",
      "Number Theory"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Sliding Subarray Beauty",
    "description": "Given an integer array nums containing n integers, find the beauty of each subarray of size k.\nThe beauty of a subarray is the xth smallest integer in the subarray if it is negative, or 0 if there are fewer than x negative integers.\nReturn an integer array containing n - k + 1 integers, which denote the beauty of the subarrays in order from the first index in the array.\n\n\nA subarray is a contiguous non-empty sequence of elements within an array.\n\n\n \nExample 1:\nInput: nums = [1,-1,-3,-2,3], k = 3, x = 2\nOutput: [-1,-2,-2]\nExplanation: There are 3 subarrays with size k = 3. \nThe first subarray is [1, -1, -3] and the 2nd smallest negative integer is -1. \nThe second subarray is [-1, -3, -2] and the 2nd smallest negative integer is -2. \nThe third subarray is [-3, -2, 3] and the 2nd smallest negative integer is -2.\nExample 2:\nInput: nums = [-1,-2,-3,-4,-5], k = 2, x = 2\nOutput: [-1,-2,-3,-4]\nExplanation: There are 4 subarrays with size k = 2.\nFor [-1, -2], the 2nd smallest negative integer is -1.\nFor [-2, -3], the 2nd smallest negative integer is -2.\nFor [-3, -4], the 2nd smallest negative integer is -3.\nFor [-4, -5], the 2nd smallest negative integer is -4. \nExample 3:\nInput: nums = [-3,1,2,-3,0,-3], k = 2, x = 1\nOutput: [-3,0,-3,-3,-3]\nExplanation: There are 5 subarrays with size k = 2.\nFor [-3, 1], the 1st smallest negative integer is -3.\nFor [1, 2], there is no negative integer so the beauty is 0.\nFor [2, -3], the 1st smallest negative integer is -3.\nFor [-3, 0], the 1st smallest negative integer is -3.\nFor [0, -3], the 1st smallest negative integer is -3.\n \nConstraints:\n\nn == nums.length \n1 <= n <= 105\n1 <= k <= n\n1 <= x <= k \n-50 <= nums[i] <= 50",
    "examples": [
      {
        "input": "Input: nums = [1,-1,-3,-2,3], k = 3, x = 2",
        "output": "Output: [-1,-2,-2]",
        "explanation": "Explanation: There are 3 subarrays with size k = 3. "
      },
      {
        "input": "Input: nums = [-1,-2,-3,-4,-5], k = 2, x = 2",
        "output": "Output: [-1,-2,-3,-4]",
        "explanation": "Explanation: There are 4 subarrays with size k = 2."
      },
      {
        "input": "Input: nums = [-3,1,2,-3,0,-3], k = 2, x = 1",
        "output": "Output: [-3,0,-3,-3,-3]",
        "explanation": "Explanation: There are 5 subarrays with size k = 2."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Sliding Window"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Calculate Delayed Arrival Time",
    "description": "You are given a positive integer arrivalTime denoting the arrival time of a train in hours, and another positive integer delayedTime denoting the amount of delay in hours.\nReturn the time when the train will arrive at the station.\nNote that the time in this problem is in 24-hours format.\n \nExample 1:\nInput: arrivalTime = 15, delayedTime = 5 \nOutput: 20 \nExplanation: Arrival time of the train was 15:00 hours. It is delayed by 5 hours. Now it will reach at 15+5 = 20 (20:00 hours).\n\nExample 2:\nInput: arrivalTime = 13, delayedTime = 11\nOutput: 0\nExplanation: Arrival time of the train was 13:00 hours. It is delayed by 11 hours. Now it will reach at 13+11=24 (Which is denoted by 00:00 in 24 hours format so return 0).\n\n \nConstraints:\n\n1 <= arrivaltime < 24\n1 <= delayedTime <= 24",
    "examples": [
      {
        "input": "Input: arrivalTime = 15, delayedTime = 5 ",
        "output": "Output: 20 ",
        "explanation": "Explanation: Arrival time of the train was 15:00 hours. It is delayed by 5 hours. Now it will reach at 15+5 = 20 (20:00 hours)."
      },
      {
        "input": "Input: arrivalTime = 13, delayedTime = 11",
        "output": "Output: 0",
        "explanation": "Explanation: Arrival time of the train was 13:00 hours. It is delayed by 11 hours. Now it will reach at 13+11=24 (Which is denoted by 00:00 in 24 hours format so return 0)."
      }
    ],
    "topics": [
      "Math"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Minimize the Total Price of the Trips",
    "description": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.\n \nExample 1:\n\nInput: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.\n\nExample 2:\n\nInput: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve.\n\n \nConstraints:\n\n1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi <= n - 1",
    "examples": [
      {
        "input": "Input: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]",
        "output": "Output: 23",
        "explanation": "Explanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half."
      },
      {
        "input": "Input: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]",
        "output": "Output: 1",
        "explanation": "Explanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half."
      }
    ],
    "topics": [
      "Array",
      "Dynamic Programming",
      "Tree",
      "Depth-First Search"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Row With Maximum Ones",
    "description": "Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.\nIn case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.\nReturn an array containing the index of the row, and the number of ones in it.\n \nExample 1:\nInput: mat = [[0,1],[1,0]]\nOutput: [0,1]\nExplanation: Both rows have the same number of 1's. So we return the index of the smaller row, 0, and the maximum count of ones (1). So, the answer is [0,1]. \n\nExample 2:\nInput: mat = [[0,0,0],[0,1,1]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So we return its index, 1, and the count. So, the answer is [1,2].\n\nExample 3:\nInput: mat = [[0,0],[1,1],[0,0]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So the answer is [1,2].\n\n \nConstraints:\n\nm == mat.length \nn == mat[i].length \n1 <= m, n <= 100 \nmat[i][j] is either 0 or 1.",
    "examples": [
      {
        "input": "Input: mat = [[0,1],[1,0]]",
        "output": "Output: [0,1]",
        "explanation": "Explanation: Both rows have the same number of 1's. So we return the index of the smaller row, 0, and the maximum count of ones (1). So, the answer is [0,1]. "
      },
      {
        "input": "Input: mat = [[0,0,0],[0,1,1]]",
        "output": "Output: [1,2]",
        "explanation": "Explanation: The row indexed 1 has the maximum count of ones (2). So we return its index, 1, and the count. So, the answer is [1,2]."
      },
      {
        "input": "Input: mat = [[0,0],[1,1],[0,0]]",
        "output": "Output: [1,2]",
        "explanation": "Explanation: The row indexed 1 has the maximum count of ones (2). So the answer is [1,2]."
      }
    ],
    "topics": [
      "Array",
      "Matrix"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Minimum Additions to Make Valid String",
    "description": "Given a string word to which you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times, return the minimum number of letters that must be inserted so that word becomes valid.\nA string is called valid if it can be formed by concatenating the string \"abc\" several times.\n \nExample 1:\nInput: word = \"b\"\nOutput: 2\nExplanation: Insert the letter \"a\" right before \"b\", and the letter \"c\" right next to \"a\" to obtain the valid string \"abc\".\n\nExample 2:\nInput: word = \"aaa\"\nOutput: 6\nExplanation: Insert letters \"b\" and \"c\" next to each \"a\" to obtain the valid string \"abcabcabc\".\n\nExample 3:\nInput: word = \"abc\"\nOutput: 0\nExplanation: word is already valid. No modifications are needed. \n\n \nConstraints:\n\n1 <= word.length <= 50\nword consists of letters \"a\", \"b\" and \"c\" only.",
    "examples": [
      {
        "input": "Input: word = \"b\"",
        "output": "Output: 2",
        "explanation": "Explanation: Insert the letter \"a\" right before \"b\", and the letter \"c\" right next to \"a\" to obtain the valid string \"abc\"."
      },
      {
        "input": "Input: word = \"aaa\"",
        "output": "Output: 6",
        "explanation": "Explanation: Insert letters \"b\" and \"c\" next to each \"a\" to obtain the valid string \"abcabcabc\"."
      },
      {
        "input": "Input: word = \"abc\"",
        "output": "Output: 0",
        "explanation": "Explanation: word is already valid. No modifications are needed. "
      }
    ],
    "topics": [
      "String",
      "Dynamic Programming",
      "Stack",
      "Greedy"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Minimum Reverse Operations",
    "description": "You are given an integer n and an integer p in the range [0, n - 1]. Representing a 0-indexed array arr of length n where all positions are set to 0's, except position p which is set to 1.\nYou are also given an integer array banned containing some positions from the array. For the ith position in banned, arr[banned[i]] = 0, and banned[i] != p.\nYou can perform multiple operations on arr. In an operation, you can choose a subarray with size k and reverse the subarray. However, the 1 in arr should never go to any of the positions in banned. In other words, after each operation arr[banned[i]] remains 0.\nReturn an array ans where for each i from [0, n - 1], ans[i] is the minimum number of reverse operations needed to bring the 1 to position i in arr, or -1 if it is impossible.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\nThe values of ans[i] are independent for all i's.\nThe reverse of an array is an array containing the values in reverse order.\n\n \nExample 1:\nInput: n = 4, p = 0, banned = [1,2], k = 4\nOutput: [0,-1,-1,1]\nExplanation: In this case k = 4 so there is only one possible reverse operation we can perform, which is reversing the whole array. Initially, 1 is placed at position 0 so the amount of operations we need for position 0 is 0. We can never place a 1 on the banned positions, so the answer for positions 1 and 2 is -1. Finally, with one reverse operation we can bring the 1 to index 3, so the answer for position 3 is 1. \n\nExample 2:\nInput: n = 5, p = 0, banned = [2,4], k = 3\nOutput: [0,-1,-1,-1,-1]\nExplanation: In this case the 1 is initially at position 0, so the answer for that position is 0. We can perform reverse operations of size 3. The 1 is currently located at position 0, so we need to reverse the subarray [0, 2] for it to leave that position, but reversing that subarray makes position 2 have a 1, which shouldn't happen. So, we can't move the 1 from position 0, making the result for all the other positions -1. \n\nExample 3:\nInput: n = 4, p = 2, banned = [0,1,3], k = 1\nOutput: [-1,-1,0,-1]\nExplanation: In this case we can only perform reverse operations of size 1. So the 1 never changes its position.\n\n \nConstraints:\n\n1 <= n <= 105\n0 <= p <= n - 1\n0 <= banned.length <= n - 1\n0 <= banned[i] <= n - 1\n1 <= k <= n \nbanned[i] != p\nall values in banned are unique",
    "examples": [
      {
        "input": "Input: n = 4, p = 0, banned = [1,2], k = 4",
        "output": "Output: [0,-1,-1,1]",
        "explanation": "Explanation: In this case k = 4 so there is only one possible reverse operation we can perform, which is reversing the whole array. Initially, 1 is placed at position 0 so the amount of operations we need for position 0 is 0. We can never place a 1 on the banned positions, so the answer for positions 1 and 2 is -1. Finally, with one reverse operation we can bring the 1 to index 3, so the answer for position 3 is 1. "
      },
      {
        "input": "Input: n = 5, p = 0, banned = [2,4], k = 3",
        "output": "Output: [0,-1,-1,-1,-1]",
        "explanation": "Explanation: In this case the 1 is initially at position 0, so the answer for that position is 0. We can perform reverse operations of size 3. The 1 is currently located at position 0, so we need to reverse the subarray [0, 2] for it to leave that position, but reversing that subarray makes position 2 have a 1, which shouldn't happen. So, we can't move the 1 from position 0, making the result for all the other positions -1. "
      },
      {
        "input": "Input: n = 4, p = 2, banned = [0,1,3], k = 1",
        "output": "Output: [-1,-1,0,-1]",
        "explanation": "Explanation: In this case we can only perform reverse operations of size 1. So the 1 never changes its position."
      }
    ],
    "topics": [
      "Array",
      "Breadth-First Search",
      "Ordered Set"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Mice and Cheese",
    "description": "There are two mice and n different types of cheese, each type of cheese should be eaten by exactly one mouse.\nA point of the cheese with index i (0-indexed) is:\n\nreward1[i] if the first mouse eats it.\nreward2[i] if the second mouse eats it.\n\nYou are given a positive integer array reward1, a positive integer array reward2, and a non-negative integer k.\nReturn the maximum points the mice can achieve if the first mouse eats exactly k types of cheese.\n \nExample 1:\nInput: reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2\nOutput: 15\nExplanation: In this example, the first mouse eats the 2nd (0-indexed) and the 3rd types of cheese, and the second mouse eats the 0th and the 1st types of cheese.\nThe total points are 4 + 4 + 3 + 4 = 15.\nIt can be proven that 15 is the maximum total points that the mice can achieve.\n\nExample 2:\nInput: reward1 = [1,1], reward2 = [1,1], k = 2\nOutput: 2\nExplanation: In this example, the first mouse eats the 0th (0-indexed) and 1st types of cheese, and the second mouse does not eat any cheese.\nThe total points are 1 + 1 = 2.\nIt can be proven that 2 is the maximum total points that the mice can achieve.\n\n \nConstraints:\n\n1 <= n == reward1.length == reward2.length <= 105\n1 <= reward1[i], reward2[i] <= 1000\n0 <= k <= n",
    "examples": [
      {
        "input": "Input: reward1 = [1,1,3,4], reward2 = [4,4,1,1], k = 2",
        "output": "Output: 15",
        "explanation": "Explanation: In this example, the first mouse eats the 2nd (0-indexed) and the 3rd types of cheese, and the second mouse eats the 0th and the 1st types of cheese."
      },
      {
        "input": "Input: reward1 = [1,1], reward2 = [1,1], k = 2",
        "output": "Output: 2",
        "explanation": "Explanation: In this example, the first mouse eats the 0th (0-indexed) and 1st types of cheese, and the second mouse does not eat any cheese."
      }
    ],
    "topics": [
      "Array",
      "Greedy",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Convert an Array Into a 2D Array With Conditions",
    "description": "You are given an integer array nums. You need to create a 2D array from nums satisfying the following conditions:\n\nThe 2D array should contain only the elements of the array nums.\nEach row in the 2D array contains distinct integers.\nThe number of rows in the 2D array should be minimal.\n\nReturn the resulting array. If there are multiple answers, return any of them.\nNote that the 2D array can have a different number of elements on each row.\n \nExample 1:\nInput: nums = [1,3,4,1,2,3,1]\nOutput: [[1,3,4,2],[1,3],[1]]\nExplanation: We can create a 2D array that contains the following rows:\n- 1,3,4,2\n- 1,3\n- 1\nAll elements of nums were used, and each row of the 2D array contains distinct integers, so it is a valid answer.\nIt can be shown that we cannot have less than 3 rows in a valid array.\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: [[4,3,2,1]]\nExplanation: All elements of the array are distinct, so we can keep all of them in the first row of the 2D array.\n\n \nConstraints:\n\n1 <= nums.length <= 200\n1 <= nums[i] <= nums.length",
    "examples": [
      {
        "input": "Input: nums = [1,3,4,1,2,3,1]",
        "output": "Output: [[1,3,4,2],[1,3],[1]]",
        "explanation": "Explanation: We can create a 2D array that contains the following rows:"
      },
      {
        "input": "Input: nums = [1,2,3,4]",
        "output": "Output: [[4,3,2,1]]",
        "explanation": "Explanation: All elements of the array are distinct, so we can keep all of them in the first row of the 2D array."
      }
    ],
    "topics": [
      "Array",
      "Hash Table"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Find the Longest Balanced Substring of a Binary String",
    "description": "You are given a binary string s consisting only of zeroes and ones.\nA substring of s is considered balanced if all zeroes are before ones and the number of zeroes is equal to the number of ones inside the substring. Notice that the empty substring is considered a balanced substring.\nReturn the length of the longest balanced substring of s.\nA substring is a contiguous sequence of characters within a string.\n \nExample 1:\nInput: s = \"01000111\"\nOutput: 6\nExplanation: The longest balanced substring is \"000111\", which has length 6.\n\nExample 2:\nInput: s = \"00111\"\nOutput: 4\nExplanation: The longest balanced substring is \"0011\", which has length 4. \n\nExample 3:\nInput: s = \"111\"\nOutput: 0\nExplanation: There is no balanced substring except the empty substring, so the answer is 0.\n\n \nConstraints:\n\n1 <= s.length <= 50\n'0' <= s[i] <= '1'",
    "examples": [
      {
        "input": "Input: s = \"01000111\"",
        "output": "Output: 6",
        "explanation": "Explanation: The longest balanced substring is \"000111\", which has length 6."
      },
      {
        "input": "Input: s = \"00111\"",
        "output": "Output: 4",
        "explanation": "Explanation: The longest balanced substring is \"0011\", which has length 4. "
      },
      {
        "input": "Input: s = \"111\"",
        "output": "Output: 0",
        "explanation": "Explanation: There is no balanced substring except the empty substring, so the answer is 0."
      }
    ],
    "topics": [
      "String"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Prime In Diagonal",
    "description": "You are given a 0-indexed two-dimensional integer array nums.\nReturn the largest prime number that lies on at least one of the diagonals of nums. In case, no prime is present on any of the diagonals, return 0.\nNote that:\n\nAn integer is prime if it is greater than 1 and has no positive integer divisors other than 1 and itself.\nAn integer val is on one of the diagonals of nums if there exists an integer i for which nums[i][i] = val or an i for which nums[i][nums.length - i - 1] = val.\n\n\nIn the above diagram, one diagonal is [1,5,9] and another diagonal is [3,5,7].\n \nExample 1:\nInput: nums = [[1,2,3],[5,6,7],[9,10,11]]\nOutput: 11\nExplanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11.\n\nExample 2:\nInput: nums = [[1,2,3],[5,17,7],[9,11,10]]\nOutput: 17\nExplanation: The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17.\n\n \nConstraints:\n\n1 <= nums.length <= 300\nnums.length == numsi.length\n1 <= nums[i][j] <= 4*106",
    "examples": [
      {
        "input": "Input: nums = [[1,2,3],[5,6,7],[9,10,11]]",
        "output": "Output: 11",
        "explanation": "Explanation: The numbers 1, 3, 6, 9, and 11 are the only numbers present on at least one of the diagonals. Since 11 is the largest prime, we return 11."
      },
      {
        "input": "Input: nums = [[1,2,3],[5,17,7],[9,11,10]]",
        "output": "Output: 17",
        "explanation": "Explanation: The numbers 1, 3, 9, 10, and 17 are all present on at least one of the diagonals. 17 is the largest prime, so we return 17."
      }
    ],
    "topics": [
      "Array",
      "Math",
      "Matrix",
      "Number Theory"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Sum of Distances",
    "description": "You are given a 0-indexed integer array nums. There exists an array arr of length nums.length, where arr[i] is the sum of |i - j| over all j such that nums[j] == nums[i] and j != i. If there is no such j, set arr[i] to be 0.\nReturn the array arr.\n \nExample 1:\nInput: nums = [1,3,1,1,2]\nOutput: [5,0,3,4,0]\nExplanation: \nWhen i = 0, nums[0] == nums[2] and nums[0] == nums[3]. Therefore, arr[0] = |0 - 2| + |0 - 3| = 5. \nWhen i = 1, arr[1] = 0 because there is no other index with value 3.\nWhen i = 2, nums[2] == nums[0] and nums[2] == nums[3]. Therefore, arr[2] = |2 - 0| + |2 - 3| = 3. \nWhen i = 3, nums[3] == nums[0] and nums[3] == nums[2]. Therefore, arr[3] = |3 - 0| + |3 - 2| = 4. \nWhen i = 4, arr[4] = 0 because there is no other index with value 2. \n\n\nExample 2:\nInput: nums = [0,5,3]\nOutput: [0,0,0]\nExplanation: Since each element in nums is distinct, arr[i] = 0 for all i.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109",
    "examples": [
      {
        "input": "Input: nums = [1,3,1,1,2]",
        "output": "Output: [5,0,3,4,0]",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: nums = [0,5,3]",
        "output": "Output: [0,0,0]",
        "explanation": "Explanation: Since each element in nums is distinct, arr[i] = 0 for all i."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Prefix Sum"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Minimize the Maximum Difference of Pairs",
    "description": "You are given a 0-indexed integer array nums and an integer p. Find p pairs of indices of nums such that the maximum difference amongst all the pairs is minimized. Also, ensure no index appears more than once amongst the p pairs.\nNote that for a pair of elements at the index i and j, the difference of this pair is |nums[i] - nums[j]|, where |x| represents the absolute value of x.\nReturn the minimum maximum difference among all p pairs. We define the maximum of an empty set to be zero.\n \nExample 1:\nInput: nums = [10,1,2,7,1,3], p = 2\nOutput: 1\nExplanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. \nThe maximum difference is max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1. Therefore, we return 1.\n\nExample 2:\nInput: nums = [4,2,1,2], p = 1\nOutput: 0\nExplanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109\n0 <= p <= (nums.length)/2",
    "examples": [
      {
        "input": "Input: nums = [10,1,2,7,1,3], p = 2",
        "output": "Output: 1",
        "explanation": "Explanation: The first pair is formed from the indices 1 and 4, and the second pair is formed from the indices 2 and 5. "
      },
      {
        "input": "Input: nums = [4,2,1,2], p = 1",
        "output": "Output: 0",
        "explanation": "Explanation: Let the indices 1 and 3 form a pair. The difference of that pair is |2 - 2| = 0, which is the minimum we can attain."
      }
    ],
    "topics": [
      "Array",
      "Binary Search",
      "Greedy"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Minimum Operations to Make All Array Elements Equal",
    "description": "You are given an array nums consisting of positive integers.\nYou are also given an integer array queries of size m. For the ith query, you want to make all of the elements of nums equal to queries[i]. You can perform the following operation on the array any number of times:\n\nIncrease or decrease an element of the array by 1.\n\nReturn an array answer of size m where answer[i] is the minimum number of operations to make all elements of nums equal to queries[i].\nNote that after each query the array is reset to its original state.\n \nExample 1:\nInput: nums = [3,1,6,8], queries = [1,5]\nOutput: [14,10]\nExplanation: For the first query we can do the following operations:\n- Decrease nums[0] 2 times, so that nums = [1,1,6,8].\n- Decrease nums[2] 5 times, so that nums = [1,1,1,8].\n- Decrease nums[3] 7 times, so that nums = [1,1,1,1].\nSo the total number of operations for the first query is 2 + 5 + 7 = 14.\nFor the second query we can do the following operations:\n- Increase nums[0] 2 times, so that nums = [5,1,6,8].\n- Increase nums[1] 4 times, so that nums = [5,5,6,8].\n- Decrease nums[2] 1 time, so that nums = [5,5,5,8].\n- Decrease nums[3] 3 times, so that nums = [5,5,5,5].\nSo the total number of operations for the second query is 2 + 4 + 1 + 3 = 10.\n\nExample 2:\nInput: nums = [2,9,6,3], queries = [10]\nOutput: [20]\nExplanation: We can increase each value in the array to 10. The total number of operations will be 8 + 1 + 4 + 7 = 20.\n\n \nConstraints:\n\nn == nums.length\nm == queries.length\n1 <= n, m <= 105\n1 <= nums[i], queries[i] <= 109",
    "examples": [
      {
        "input": "Input: nums = [3,1,6,8], queries = [1,5]",
        "output": "Output: [14,10]",
        "explanation": "Explanation: For the first query we can do the following operations:"
      },
      {
        "input": "Input: nums = [2,9,6,3], queries = [10]",
        "output": "Output: [20]",
        "explanation": "Explanation: We can increase each value in the array to 10. The total number of operations will be 8 + 1 + 4 + 7 = 20."
      }
    ],
    "topics": [
      "Array",
      "Binary Search",
      "Sorting",
      "Prefix Sum"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Collect Coins in a Tree",
    "description": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given an integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree. You are also given an array coins of size n where coins[i] can be either 0 or 1, where 1 indicates the presence of a coin in the vertex i.\nInitially, you choose to start at any vertex in the tree. Then, you can perform the following operations any number of times: \n\nCollect all the coins that are at a distance of at most 2 from the current vertex, or\nMove to any adjacent vertex in the tree.\n\nFind the minimum number of edges you need to go through to collect all the coins and go back to the initial vertex.\nNote that if you pass an edge several times, you need to count it into the answer several times.\n \nExample 1:\n\nInput: coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]\nOutput: 2\nExplanation: Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2.\n\nExample 2:\n\nInput: coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]\nOutput: 2\nExplanation: Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0.\n\n \nConstraints:\n\nn == coins.length\n1 <= n <= 3 * 104\n0 <= coins[i] <= 1\nedges.length == n - 1\nedges[i].length == 2\n0 <= ai, bi < n\nai != bi\nedges represents a valid tree.",
    "examples": [
      {
        "input": "Input: coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]",
        "output": "Output: 2",
        "explanation": "Explanation: Start at vertex 2, collect the coin at vertex 0, move to vertex 3, collect the coin at vertex 5 then move back to vertex 2."
      },
      {
        "input": "Input: coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]",
        "output": "Output: 2",
        "explanation": "Explanation: Start at vertex 0, collect the coins at vertices 4 and 3, move to vertex 2,  collect the coin at vertex 7, then move back to vertex 0."
      }
    ],
    "topics": [
      "Array",
      "Tree",
      "Graph",
      "Topological Sort"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Prime Subtraction Operation",
    "description": "You are given a 0-indexed integer array nums of length n.\nYou can perform the following operation as many times as you want:\n\nPick an index i that you haven’t picked before, and pick a prime p strictly less than nums[i], then subtract p from nums[i].\n\nReturn true if you can make nums a strictly increasing array using the above operation and false otherwise.\nA strictly increasing array is an array whose each element is strictly greater than its preceding element.\n \nExample 1:\nInput: nums = [4,9,6,10]\nOutput: true\nExplanation: In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10].\nIn the second operation: i = 1, p = 7, subtract 7 from nums[1], so nums becomes equal to [1,2,6,10].\nAfter the second operation, nums is sorted in strictly increasing order, so the answer is true.\nExample 2:\nInput: nums = [6,8,11,12]\nOutput: true\nExplanation: Initially nums is sorted in strictly increasing order, so we don't need to make any operations.\nExample 3:\nInput: nums = [5,8,3]\nOutput: false\nExplanation: It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false.\n \nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 1000\nnums.length == n",
    "examples": [
      {
        "input": "Input: nums = [4,9,6,10]",
        "output": "Output: true",
        "explanation": "Explanation: In the first operation: Pick i = 0 and p = 3, and then subtract 3 from nums[0], so that nums becomes [1,9,6,10]."
      },
      {
        "input": "Input: nums = [6,8,11,12]",
        "output": "Output: true",
        "explanation": "Explanation: Initially nums is sorted in strictly increasing order, so we don't need to make any operations."
      },
      {
        "input": "Input: nums = [5,8,3]",
        "output": "Output: false",
        "explanation": "Explanation: It can be proven that there is no way to perform operations to make nums sorted in strictly increasing order, so the answer is false."
      }
    ],
    "topics": [
      "Array",
      "Math",
      "Binary Search",
      "Greedy",
      "Number Theory"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "K Items With the Maximum Sum",
    "description": "There is a bag that consists of items, each item has a number 1, 0, or -1 written on it.\nYou are given four non-negative integers numOnes, numZeros, numNegOnes, and k.\nThe bag initially contains:\n\nnumOnes items with 1s written on them.\nnumZeroes items with 0s written on them.\nnumNegOnes items with -1s written on them.\n\nWe want to pick exactly k items among the available items. Return the maximum possible sum of numbers written on the items.\n \nExample 1:\nInput: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2\nOutput: 2\nExplanation: We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 2 items with 1 written on them and get a sum in a total of 2.\nIt can be proven that 2 is the maximum possible sum.\n\nExample 2:\nInput: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4\nOutput: 3\nExplanation: We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 3 items with 1 written on them, and 1 item with 0 written on it, and get a sum in a total of 3.\nIt can be proven that 3 is the maximum possible sum.\n\n \nConstraints:\n\n0 <= numOnes, numZeros, numNegOnes <= 50\n0 <= k <= numOnes + numZeros + numNegOnes",
    "examples": [
      {
        "input": "Input: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 2",
        "output": "Output: 2",
        "explanation": "Explanation: We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 2 items with 1 written on them and get a sum in a total of 2."
      },
      {
        "input": "Input: numOnes = 3, numZeros = 2, numNegOnes = 0, k = 4",
        "output": "Output: 3",
        "explanation": "Explanation: We have a bag of items with numbers written on them {1, 1, 1, 0, 0}. We take 3 items with 1 written on them, and 1 item with 0 written on it, and get a sum in a total of 3."
      }
    ],
    "topics": [
      "Math",
      "Greedy"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Left and Right Sum Differences",
    "description": "Given a 0-indexed integer array nums, find a 0-indexed integer array answer where:\n\nanswer.length == nums.length.\nanswer[i] = |leftSum[i] - rightSum[i]|.\n\nWhere:\n\nleftSum[i] is the sum of elements to the left of the index i in the array nums. If there is no such element, leftSum[i] = 0.\nrightSum[i] is the sum of elements to the right of the index i in the array nums. If there is no such element, rightSum[i] = 0.\n\nReturn the array answer.\n \nExample 1:\nInput: nums = [10,4,8,3]\nOutput: [15,1,11,22]\nExplanation: The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0].\nThe array answer is [|0 - 15|,|10 - 11|,|14 - 3|,|22 - 0|] = [15,1,11,22].\n\nExample 2:\nInput: nums = [1]\nOutput: [0]\nExplanation: The array leftSum is [0] and the array rightSum is [0].\nThe array answer is [|0 - 0|] = [0].\n\n \nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 105",
    "examples": [
      {
        "input": "Input: nums = [10,4,8,3]",
        "output": "Output: [15,1,11,22]",
        "explanation": "Explanation: The array leftSum is [0,10,14,22] and the array rightSum is [15,11,3,0]."
      },
      {
        "input": "Input: nums = [1]",
        "output": "Output: [0]",
        "explanation": "Explanation: The array leftSum is [0] and the array rightSum is [0]."
      }
    ],
    "topics": [
      "Array",
      "Prefix Sum"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Find the Divisibility Array of a String",
    "description": "You are given a 0-indexed string word of length n consisting of digits, and a positive integer m.\nThe divisibility array div of word is an integer array of length n such that:\n\ndiv[i] = 1 if the numeric value of word[0,...,i] is divisible by m, or\ndiv[i] = 0 otherwise.\n\nReturn the divisibility array of word.\n \nExample 1:\nInput: word = \"998244353\", m = 3\nOutput: [1,1,0,0,0,1,1,0,0]\nExplanation: There are only 4 prefixes that are divisible by 3: \"9\", \"99\", \"998244\", and \"9982443\".\n\nExample 2:\nInput: word = \"1010\", m = 10\nOutput: [0,1,0,1]\nExplanation: There are only 2 prefixes that are divisible by 10: \"10\", and \"1010\".\n\n \nConstraints:\n\n1 <= n <= 105\nword.length == n\nword consists of digits from 0 to 9\n1 <= m <= 109",
    "examples": [
      {
        "input": "Input: word = \"998244353\", m = 3",
        "output": "Output: [1,1,0,0,0,1,1,0,0]",
        "explanation": "Explanation: There are only 4 prefixes that are divisible by 3: \"9\", \"99\", \"998244\", and \"9982443\"."
      },
      {
        "input": "Input: word = \"1010\", m = 10",
        "output": "Output: [0,1,0,1]",
        "explanation": "Explanation: There are only 2 prefixes that are divisible by 10: \"10\", and \"1010\"."
      }
    ],
    "topics": [
      "Array",
      "Math",
      "String"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Find the Maximum Number of Marked Indices",
    "description": "You are given a 0-indexed integer array nums.\nInitially, all of the indices are unmarked. You are allowed to make this operation any number of times:\n\nPick two different unmarked indices i and j such that 2 * nums[i] <= nums[j], then mark i and j.\n\nReturn the maximum possible number of marked indices in nums using the above operation any number of times.\n \nExample 1:\nInput: nums = [3,5,2,4]\nOutput: 2\nExplanation: In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] <= nums[1]. Then mark index 2 and 1.\nIt can be shown that there's no other valid operation so the answer is 2.\n\nExample 2:\nInput: nums = [9,2,5,4]\nOutput: 4\nExplanation: In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] <= nums[0]. Then mark index 3 and 0.\nIn the second operation: pick i = 1 and j = 2, the operation is allowed because 2 * nums[1] <= nums[2]. Then mark index 1 and 2.\nSince there is no other operation, the answer is 4.\n\nExample 3:\nInput: nums = [7,6,8]\nOutput: 0\nExplanation: There is no valid operation to do, so the answer is 0.\n\n\n \nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109",
    "examples": [
      {
        "input": "Input: nums = [3,5,2,4]",
        "output": "Output: 2",
        "explanation": "Explanation: In the first operation: pick i = 2 and j = 1, the operation is allowed because 2 * nums[2] <= nums[1]. Then mark index 2 and 1."
      },
      {
        "input": "Input: nums = [9,2,5,4]",
        "output": "Output: 4",
        "explanation": "Explanation: In the first operation: pick i = 3 and j = 0, the operation is allowed because 2 * nums[3] <= nums[0]. Then mark index 3 and 0."
      },
      {
        "input": "Input: nums = [7,6,8]",
        "output": "Output: 0",
        "explanation": "Explanation: There is no valid operation to do, so the answer is 0."
      }
    ],
    "topics": [
      "Array",
      "Two Pointers",
      "Binary Search",
      "Greedy",
      "Sorting"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Minimum Time to Visit a Cell In a Grid",
    "description": "You are given a m x n matrix grid consisting of non-negative integers where grid[row][col] represents the minimum time required to be able to visit the cell (row, col), which means you can visit the cell (row, col) only when the time you visit it is greater than or equal to grid[row][col].\nYou are standing in the top-left cell of the matrix in the 0th second, and you must move to any adjacent cell in the four directions: up, down, left, and right. Each move you make takes 1 second.\nReturn the minimum time required in which you can visit the bottom-right cell of the matrix. If you cannot visit the bottom-right cell, then return -1.\n \nExample 1:\n\nInput: grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]\nOutput: 7\nExplanation: One of the paths that we can take is the following:\n- at t = 0, we are on the cell (0,0).\n- at t = 1, we move to the cell (0,1). It is possible because grid[0][1] <= 1.\n- at t = 2, we move to the cell (1,1). It is possible because grid[1][1] <= 2.\n- at t = 3, we move to the cell (1,2). It is possible because grid[1][2] <= 3.\n- at t = 4, we move to the cell (1,1). It is possible because grid[1][1] <= 4.\n- at t = 5, we move to the cell (1,2). It is possible because grid[1][2] <= 5.\n- at t = 6, we move to the cell (1,3). It is possible because grid[1][3] <= 6.\n- at t = 7, we move to the cell (2,3). It is possible because grid[2][3] <= 7.\nThe final time is 7. It can be shown that it is the minimum time possible.\n\nExample 2:\n\nInput: grid = [[0,2,4],[3,2,1],[1,0,4]]\nOutput: -1\nExplanation: There is no path from the top left to the bottom-right cell.\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\n0 <= grid[i][j] <= 105\ngrid[0][0] == 0",
    "examples": [
      {
        "input": "Input: grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]",
        "output": "Output: 7",
        "explanation": "Explanation: One of the paths that we can take is the following:"
      },
      {
        "input": "Input: grid = [[0,2,4],[3,2,1],[1,0,4]]",
        "output": "Output: -1",
        "explanation": "Explanation: There is no path from the top left to the bottom-right cell."
      }
    ],
    "topics": [
      "Array",
      "Breadth-First Search",
      "Graph",
      "Heap (Priority Queue)",
      "Matrix",
      "Shortest Path"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Minimum Operations to Reduce an Integer to 0",
    "description": "You are given a positive integer n, you can do the following operation any number of times:\n\nAdd or subtract a power of 2 from n.\n\nReturn the minimum number of operations to make n equal to 0.\nA number x is power of 2 if x == 2i where i >= 0.\n \nExample 1:\nInput: n = 39\nOutput: 3\nExplanation: We can do the following operations:\n- Add 20 = 1 to n, so now n = 40.\n- Subtract 23 = 8 from n, so now n = 32.\n- Subtract 25 = 32 from n, so now n = 0.\nIt can be shown that 3 is the minimum number of operations we need to make n equal to 0.\n\nExample 2:\nInput: n = 54\nOutput: 3\nExplanation: We can do the following operations:\n- Add 21 = 2 to n, so now n = 56.\n- Add 23 = 8 to n, so now n = 64.\n- Subtract 26 = 64 from n, so now n = 0.\nSo the minimum number of operations is 3.\n\n \nConstraints:\n\n1 <= n <= 105",
    "examples": [
      {
        "input": "Input: n = 39",
        "output": "Output: 3",
        "explanation": "Explanation: We can do the following operations:"
      },
      {
        "input": "Input: n = 54",
        "output": "Output: 3",
        "explanation": "Explanation: We can do the following operations:"
      }
    ],
    "topics": [
      "Dynamic Programming",
      "Greedy",
      "Bit Manipulation"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Count the Number of Square-Free Subsets",
    "description": "You are given a positive integer 0-indexed array nums.\nA subset of the array nums is square-free if the product of its elements is a square-free integer.\nA square-free integer is an integer that is divisible by no square number other than 1.\nReturn the number of square-free non-empty subsets of the array nums. Since the answer may be too large, return it modulo 109 + 7.\nA non-empty subset of nums is an array that can be obtained by deleting some (possibly none but not all) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.\n \nExample 1:\nInput: nums = [3,4,4,5]\nOutput: 3\nExplanation: There are 3 square-free subsets in this example:\n- The subset consisting of the 0th element [3]. The product of its elements is 3, which is a square-free integer.\n- The subset consisting of the 3rd element [5]. The product of its elements is 5, which is a square-free integer.\n- The subset consisting of 0th and 3rd elements [3,5]. The product of its elements is 15, which is a square-free integer.\nIt can be proven that there are no more than 3 square-free subsets in the given array.\nExample 2:\nInput: nums = [1]\nOutput: 1\nExplanation: There is 1 square-free subset in this example:\n- The subset consisting of the 0th element [1]. The product of its elements is 1, which is a square-free integer.\nIt can be proven that there is no more than 1 square-free subset in the given array.\n\n \nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 30",
    "examples": [
      {
        "input": "Input: nums = [3,4,4,5]",
        "output": "Output: 3",
        "explanation": "Explanation: There are 3 square-free subsets in this example:"
      },
      {
        "input": "Input: nums = [1]",
        "output": "Output: 1",
        "explanation": "Explanation: There is 1 square-free subset in this example:"
      }
    ],
    "topics": [
      "Array",
      "Math",
      "Dynamic Programming",
      "Bit Manipulation",
      "Bitmask"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Find the String with LCP",
    "description": "We define the lcp matrix of any 0-indexed string word of n lowercase English letters as an n x n grid such that:\n\nlcp[i][j] is equal to the length of the longest common prefix between the substrings word[i,n-1] and word[j,n-1].\n\nGiven an n x n matrix lcp, return the alphabetically smallest string word that corresponds to lcp. If there is no such string, return an empty string.\nA string a is lexicographically smaller than a string b (of the same length) if in the first position where a and b differ, string a has a letter that appears earlier in the alphabet than the corresponding letter in b. For example, \"aabd\" is lexicographically smaller than \"aaca\" because the first position they differ is at the third letter, and 'b' comes before 'c'.\n \nExample 1:\nInput: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]\nOutput: \"abab\"\nExplanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\".\n\nExample 2:\nInput: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]\nOutput: \"aaaa\"\nExplanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\". \n\nExample 3:\nInput: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]\nOutput: \"\"\nExplanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists.\n\n \nConstraints:\n\n1 <= n == lcp.length == lcp[i].length <= 1000\n0 <= lcp[i][j] <= n",
    "examples": [
      {
        "input": "Input: lcp = [[4,0,2,0],[0,3,0,1],[2,0,2,0],[0,1,0,1]]",
        "output": "Output: \"abab\"",
        "explanation": "Explanation: lcp corresponds to any 4 letter string with two alternating letters. The lexicographically smallest of them is \"abab\"."
      },
      {
        "input": "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,1]]",
        "output": "Output: \"aaaa\"",
        "explanation": "Explanation: lcp corresponds to any 4 letter string with a single distinct letter. The lexicographically smallest of them is \"aaaa\". "
      },
      {
        "input": "Input: lcp = [[4,3,2,1],[3,3,2,1],[2,2,2,1],[1,1,1,3]]",
        "output": "Output: \"\"",
        "explanation": "Explanation: lcp[3][3] cannot be equal to 3 since word[3,...,3] consists of only a single letter; Thus, no answer exists."
      }
    ],
    "topics": [
      "String",
      "Dynamic Programming",
      "Greedy",
      "Union Find"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Merge Two 2D Arrays by Summing Values",
    "description": "You are given two 2D integer arrays nums1 and nums2.\n\nnums1[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.\nnums2[i] = [idi, vali] indicate that the number with the id idi has a value equal to vali.\n\nEach array contains unique ids and is sorted in ascending order by id.\nMerge the two arrays into one array that is sorted in ascending order by id, respecting the following conditions:\n\nOnly ids that appear in at least one of the two arrays should be included in the resulting array.\nEach id should be included only once and its value should be the sum of the values of this id in the two arrays. If the id does not exist in one of the two arrays then its value in that array is considered to be 0.\n\nReturn the resulting array. The returned array must be sorted in ascending order by id.\n \nExample 1:\nInput: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]\nOutput: [[1,6],[2,3],[3,2],[4,6]]\nExplanation: The resulting array contains the following:\n- id = 1, the value of this id is 2 + 4 = 6.\n- id = 2, the value of this id is 3.\n- id = 3, the value of this id is 2.\n- id = 4, the value of this id is 5 + 1 = 6.\n\nExample 2:\nInput: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]\nOutput: [[1,3],[2,4],[3,6],[4,3],[5,5]]\nExplanation: There are no common ids, so we just include each id with its value in the resulting list.\n\n \nConstraints:\n\n1 <= nums1.length, nums2.length <= 200\nnums1[i].length == nums2[j].length == 2\n1 <= idi, vali <= 1000\nBoth arrays contain unique ids.\nBoth arrays are in strictly ascending order by id.",
    "examples": [
      {
        "input": "Input: nums1 = [[1,2],[2,3],[4,5]], nums2 = [[1,4],[3,2],[4,1]]",
        "output": "Output: [[1,6],[2,3],[3,2],[4,6]]",
        "explanation": "Explanation: The resulting array contains the following:"
      },
      {
        "input": "Input: nums1 = [[2,4],[3,6],[5,5]], nums2 = [[1,3],[4,3]]",
        "output": "Output: [[1,3],[2,4],[3,6],[4,3],[5,5]]",
        "explanation": "Explanation: There are no common ids, so we just include each id with its value in the resulting list."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Two Pointers"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Minimum Score by Changing Two Elements",
    "description": "You are given a 0-indexed integer array nums.\n\nThe low score of nums is the minimum value of |nums[i] - nums[j]| over all 0 <= i < j < nums.length.\nThe high score of nums is the maximum value of |nums[i] - nums[j]| over all 0 <= i < j < nums.length.\nThe score of nums is the sum of the high and low scores of nums.\n\nTo minimize the score of nums, we can change the value of at most two elements of nums.\nReturn the minimum possible score after changing the value of at most two elements of nums.\nNote that |x| denotes the absolute value of x.\n \nExample 1:\nInput: nums = [1,4,3]\nOutput: 0\nExplanation: Change value of nums[1] and nums[2] to 1 so that nums becomes [1,1,1]. Now, the value of |nums[i] - nums[j]| is always equal to 0, so we return 0 + 0 = 0.\n\nExample 2:\nInput: nums = [1,4,7,8,5]\nOutput: 3\nExplanation: Change nums[0] and nums[1] to be 6. Now nums becomes [6,6,7,8,5].\nOur low score is achieved when i = 0 and j = 1, in which case |nums[i] - nums[j]| = |6 - 6| = 0.\nOur high score is achieved when i = 3 and j = 4, in which case |nums[i] - nums[j]| = |8 - 5| = 3.\nThe sum of our high and low score is 3, which we can prove to be minimal.\n\n \nConstraints:\n\n3 <= nums.length <= 105\n1 <= nums[i] <= 109",
    "examples": [
      {
        "input": "Input: nums = [1,4,3]",
        "output": "Output: 0",
        "explanation": "Explanation: Change value of nums[1] and nums[2] to 1 so that nums becomes [1,1,1]. Now, the value of |nums[i] - nums[j]| is always equal to 0, so we return 0 + 0 = 0."
      },
      {
        "input": "Input: nums = [1,4,7,8,5]",
        "output": "Output: 3",
        "explanation": "Explanation: Change nums[0] and nums[1] to be 6. Now nums becomes [6,6,7,8,5]."
      }
    ],
    "topics": [
      "Array",
      "Greedy",
      "Sorting"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Minimum Impossible OR",
    "description": "You are given a 0-indexed integer array nums.\nWe say that an integer x is expressible from nums if there exist some integers 0 <= index1 < index2 < ... < indexk < nums.length for which nums[index1] | nums[index2] | ... | nums[indexk] = x. In other words, an integer is expressible if it can be written as the bitwise OR of some subsequence of nums.\nReturn the minimum positive non-zero integer that is not expressible from nums.\n \nExample 1:\nInput: nums = [2,1]\nOutput: 4\nExplanation: 1 and 2 are already present in the array. We know that 3 is expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is not expressible, we return 4.\n\nExample 2:\nInput: nums = [5,3,2]\nOutput: 1\nExplanation: We can show that 1 is the smallest number that is not expressible.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109",
    "examples": [
      {
        "input": "Input: nums = [2,1]",
        "output": "Output: 4",
        "explanation": "Explanation: 1 and 2 are already present in the array. We know that 3 is expressible, since nums[0] | nums[1] = 2 | 1 = 3. Since 4 is not expressible, we return 4."
      },
      {
        "input": "Input: nums = [5,3,2]",
        "output": "Output: 1",
        "explanation": "Explanation: We can show that 1 is the smallest number that is not expressible."
      }
    ],
    "topics": [
      "Array",
      "Bit Manipulation",
      "Brainteaser"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Maximum Difference by Remapping a Digit",
    "description": "You are given an integer num. You know that Danny Mittal will sneakily remap one of the 10 possible digits (0 to 9) to another digit.\nReturn the difference between the maximum and minimum values Danny can make by remapping exactly one digit in num.\nNotes:\n\nWhen Danny remaps a digit d1 to another digit d2, Danny replaces all occurrences of d1 in num with d2.\nDanny can remap a digit to itself, in which case num does not change.\nDanny can remap different digits for obtaining minimum and maximum values respectively.\nThe resulting number after remapping can contain leading zeroes.\nWe mentioned \"Danny Mittal\" to congratulate him on being in the top 10 in Weekly Contest 326.\n\n \nExample 1:\nInput: num = 11891\nOutput: 99009\nExplanation: \nTo achieve the maximum value, Danny can remap the digit 1 to the digit 9 to yield 99899.\nTo achieve the minimum value, Danny can remap the digit 1 to the digit 0, yielding 890.\nThe difference between these two numbers is 99009.\n\nExample 2:\nInput: num = 90\nOutput: 99\nExplanation:\nThe maximum value that can be returned by the function is 99 (if 0 is replaced by 9) and the minimum value that can be returned by the function is 0 (if 9 is replaced by 0).\nThus, we return 99.\n \nConstraints:\n\n1 <= num <= 108",
    "examples": [
      {
        "input": "Input: num = 11891",
        "output": "Output: 99009",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: num = 90",
        "output": "Output: 99",
        "explanation": ""
      }
    ],
    "topics": [
      "Math",
      "Greedy"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Handling Sum Queries After Update",
    "description": "You are given two 0-indexed arrays nums1 and nums2 and a 2D array queries of queries. There are three types of queries:\n\nFor a query of type 1, queries[i] = [1, l, r]. Flip the values from 0 to 1 and from 1 to 0 in nums1 from index l to index r. Both l and r are 0-indexed.\nFor a query of type 2, queries[i] = [2, p, 0]. For every index 0 <= i < n, set nums2[i] = nums2[i] + nums1[i] * p.\nFor a query of type 3, queries[i] = [3, 0, 0]. Find the sum of the elements in nums2.\n\nReturn an array containing all the answers to the third type queries.\n \nExample 1:\nInput: nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]\nOutput: [3]\nExplanation: After the first query nums1 becomes [1,1,1]. After the second query, nums2 becomes [1,1,1], so the answer to the third query is 3. Thus, [3] is returned.\n\nExample 2:\nInput: nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]\nOutput: [5]\nExplanation: After the first query, nums2 remains [5], so the answer to the second query is 5. Thus, [5] is returned.\n\n \nConstraints:\n\n1 <= nums1.length,nums2.length <= 105\nnums1.length = nums2.length\n1 <= queries.length <= 105\nqueries[i].length = 3\n0 <= l <= r <= nums1.length - 1\n0 <= p <= 106\n0 <= nums1[i] <= 1\n0 <= nums2[i] <= 109",
    "examples": [
      {
        "input": "Input: nums1 = [1,0,1], nums2 = [0,0,0], queries = [[1,1,1],[2,1,0],[3,0,0]]",
        "output": "Output: [3]",
        "explanation": "Explanation: After the first query nums1 becomes [1,1,1]. After the second query, nums2 becomes [1,1,1], so the answer to the third query is 3. Thus, [3] is returned."
      },
      {
        "input": "Input: nums1 = [1], nums2 = [5], queries = [[2,0,0],[3,0,0]]",
        "output": "Output: [5]",
        "explanation": "Explanation: After the first query, nums2 remains [5], so the answer to the second query is 5. Thus, [5] is returned."
      }
    ],
    "topics": [
      "Array",
      "Segment Tree"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Subsequence With the Minimum Score",
    "description": "You are given two strings s and t.\nYou are allowed to remove any number of characters from the string t.\nThe score of the string is 0 if no characters are removed from the string t, otherwise:\n\nLet left be the minimum index among all removed characters.\nLet right be the maximum index among all removed characters.\n\nThen the score of the string is right - left + 1.\nReturn the minimum possible score to make t a subsequence of s.\nA subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., \"ace\" is a subsequence of \"abcde\" while \"aec\" is not).\n \nExample 1:\nInput: s = \"abacaba\", t = \"bzaa\"\nOutput: 1\nExplanation: In this example, we remove the character \"z\" at index 1 (0-indexed).\nThe string t becomes \"baa\" which is a subsequence of the string \"abacaba\" and the score is 1 - 1 + 1 = 1.\nIt can be proven that 1 is the minimum score that we can achieve.\n\nExample 2:\nInput: s = \"cde\", t = \"xyz\"\nOutput: 3\nExplanation: In this example, we remove characters \"x\", \"y\" and \"z\" at indices 0, 1, and 2 (0-indexed).\nThe string t becomes \"\" which is a subsequence of the string \"cde\" and the score is 2 - 0 + 1 = 3.\nIt can be proven that 3 is the minimum score that we can achieve.\n\n \nConstraints:\n\n1 <= s.length, t.length <= 105\ns and t consist of only lowercase English letters.",
    "examples": [
      {
        "input": "Input: s = \"abacaba\", t = \"bzaa\"",
        "output": "Output: 1",
        "explanation": "Explanation: In this example, we remove the character \"z\" at index 1 (0-indexed)."
      },
      {
        "input": "Input: s = \"cde\", t = \"xyz\"",
        "output": "Output: 3",
        "explanation": "Explanation: In this example, we remove characters \"x\", \"y\" and \"z\" at indices 0, 1, and 2 (0-indexed)."
      }
    ],
    "topics": [
      "Two Pointers",
      "String",
      "Binary Search"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Substring XOR Queries",
    "description": "You are given a binary string s, and a 2D integer array queries where queries[i] = [firsti, secondi].\nFor the ith query, find the shortest substring of s whose decimal value, val, yields secondi when bitwise XORed with firsti. In other words, val ^ firsti == secondi.\nThe answer to the ith query is the endpoints (0-indexed) of the substring [lefti, righti] or [-1, -1] if no such substring exists. If there are multiple answers, choose the one with the minimum lefti.\nReturn an array ans where ans[i] = [lefti, righti] is the answer to the ith query.\nA substring is a contiguous non-empty sequence of characters within a string.\n \nExample 1:\nInput: s = \"101101\", queries = [[0,5],[1,2]]\nOutput: [[0,2],[2,3]]\nExplanation: For the first query the substring in range [0,2] is \"101\" which has a decimal value of 5, and 5 ^ 0 = 5, hence the answer to the first query is [0,2]. In the second query, the substring in range [2,3] is \"11\", and has a decimal value of 3, and 3 ^ 1 = 2. So, [2,3] is returned for the second query. \n\n\nExample 2:\nInput: s = \"0101\", queries = [[12,8]]\nOutput: [[-1,-1]]\nExplanation: In this example there is no substring that answers the query, hence [-1,-1] is returned.\n\nExample 3:\nInput: s = \"1\", queries = [[4,5]]\nOutput: [[0,0]]\nExplanation: For this example, the substring in range [0,0] has a decimal value of 1, and 1 ^ 4 = 5. So, the answer is [0,0].\n\n \nConstraints:\n\n1 <= s.length <= 104\ns[i] is either '0' or '1'.\n1 <= queries.length <= 105\n0 <= firsti, secondi <= 109",
    "examples": [
      {
        "input": "Input: s = \"101101\", queries = [[0,5],[1,2]]",
        "output": "Output: [[0,2],[2,3]]",
        "explanation": "Explanation: For the first query the substring in range [0,2] is \"101\" which has a decimal value of 5, and 5 ^ 0 = 5, hence the answer to the first query is [0,2]. In the second query, the substring in range [2,3] is \"11\", and has a decimal value of 3, and 3 ^ 1 = 2. So, [2,3] is returned for the second query. "
      },
      {
        "input": "Input: s = \"0101\", queries = [[12,8]]",
        "output": "Output: [[-1,-1]]",
        "explanation": "Explanation: In this example there is no substring that answers the query, hence [-1,-1] is returned."
      },
      {
        "input": "Input: s = \"1\", queries = [[4,5]]",
        "output": "Output: [[0,0]]",
        "explanation": "Explanation: For this example, the substring in range [0,0] has a decimal value of 1, and 1 ^ 4 = 5. So, the answer is [0,0]."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "String",
      "Bit Manipulation"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Count the Number of Fair Pairs",
    "description": "Given a 0-indexed integer array nums of size n and two integers lower and upper, return the number of fair pairs.\nA pair (i, j) is fair if:\n\n0 <= i < j < n, and\nlower <= nums[i] + nums[j] <= upper\n\n \nExample 1:\nInput: nums = [0,1,7,4,4,5], lower = 3, upper = 6\nOutput: 6\nExplanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5).\n\nExample 2:\nInput: nums = [1,7,9,2,5], lower = 11, upper = 11\nOutput: 1\nExplanation: There is a single fair pair: (2,3).\n\n \nConstraints:\n\n1 <= nums.length <= 105\nnums.length == n\n-109 <= nums[i] <= 109\n-109 <= lower <= upper <= 109",
    "examples": [
      {
        "input": "Input: nums = [0,1,7,4,4,5], lower = 3, upper = 6",
        "output": "Output: 6",
        "explanation": "Explanation: There are 6 fair pairs: (0,3), (0,4), (0,5), (1,3), (1,4), and (1,5)."
      },
      {
        "input": "Input: nums = [1,7,9,2,5], lower = 11, upper = 11",
        "output": "Output: 1",
        "explanation": "Explanation: There is a single fair pair: (2,3)."
      }
    ],
    "topics": [
      "Array",
      "Two Pointers",
      "Binary Search",
      "Sorting"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Find the Array Concatenation Value",
    "description": "You are given a 0-indexed integer array nums.\nThe concatenation of two numbers is the number formed by concatenating their numerals.\n\nFor example, the concatenation of 15, 49 is 1549.\n\nThe concatenation value of nums is initially equal to 0. Perform this operation until nums becomes empty:\n\nIf there exists more than one number in nums, pick the first element and last element in nums respectively and add the value of their concatenation to the concatenation value of nums, then delete the first and last element from nums.\nIf one element exists, add its value to the concatenation value of nums, then delete it.\n\nReturn the concatenation value of the nums.\n \nExample 1:\nInput: nums = [7,52,2,4]\nOutput: 596\nExplanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 7, and the last element, 4.\nTheir concatenation is 74, and we add it to the concatenation value, so it becomes equal to 74.\nThen we delete them from nums, so nums becomes equal to [52,2].\n - In the second operation:\nWe pick the first element, 52, and the last element, 2.\nTheir concatenation is 522, and we add it to the concatenation value, so it becomes equal to 596.\nThen we delete them from the nums, so nums becomes empty.\nSince the concatenation value is 596 so the answer is 596.\n\nExample 2:\nInput: nums = [5,14,13,8,12]\nOutput: 673\nExplanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0.\n - In the first operation:\nWe pick the first element, 5, and the last element, 12.\nTheir concatenation is 512, and we add it to the concatenation value, so it becomes equal to 512.\nThen we delete them from the nums, so nums becomes equal to [14,13,8].\n - In the second operation:\nWe pick the first element, 14, and the last element, 8.\nTheir concatenation is 148, and we add it to the concatenation value, so it becomes equal to 660.\nThen we delete them from the nums, so nums becomes equal to [13].\n - In the third operation:\nnums has only one element, so we pick 13 and add it to the concatenation value, so it becomes equal to 673.\nThen we delete it from nums, so nums become empty.\nSince the concatenation value is 673 so the answer is 673.\n\n \nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 104",
    "examples": [
      {
        "input": "Input: nums = [7,52,2,4]",
        "output": "Output: 596",
        "explanation": "Explanation: Before performing any operation, nums is [7,52,2,4] and concatenation value is 0."
      },
      {
        "input": "Input: nums = [5,14,13,8,12]",
        "output": "Output: 673",
        "explanation": "Explanation: Before performing any operation, nums is [5,14,13,8,12] and concatenation value is 0."
      }
    ],
    "topics": [
      "Array",
      "Two Pointers",
      "Simulation"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Minimum Number of Visited Cells in a Grid",
    "description": "You are given a 0-indexed m x n integer matrix grid. Your initial position is at the top-left cell (0, 0).\nStarting from the cell (i, j), you can move to one of the following cells:\n\nCells (i, k) with j < k <= grid[i][j] + j (rightward movement), or\nCells (k, j) with i < k <= grid[i][j] + i (downward movement).\n\nReturn the minimum number of cells you need to visit to reach the bottom-right cell (m - 1, n - 1). If there is no valid path, return -1.\n \nExample 1:\n\nInput: grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]\nOutput: 4\nExplanation: The image above shows one of the paths that visits exactly 4 cells.\n\nExample 2:\n\nInput: grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]\nOutput: 3\nExplanation: The image above shows one of the paths that visits exactly 3 cells.\n\nExample 3:\n\nInput: grid = [[2,1,0],[1,0,0]]\nOutput: -1\nExplanation: It can be proven that no path exists.\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n1 <= m * n <= 105\n0 <= grid[i][j] < m * n\ngrid[m - 1][n - 1] == 0",
    "examples": [
      {
        "input": "Input: grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]",
        "output": "Output: 4",
        "explanation": "Explanation: The image above shows one of the paths that visits exactly 4 cells."
      },
      {
        "input": "Input: grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]",
        "output": "Output: 3",
        "explanation": "Explanation: The image above shows one of the paths that visits exactly 3 cells."
      },
      {
        "input": "Input: grid = [[2,1,0],[1,0,0]]",
        "output": "Output: -1",
        "explanation": "Explanation: It can be proven that no path exists."
      }
    ],
    "topics": [
      "Array",
      "Binary Search",
      "Dynamic Programming",
      "Stack",
      "Union Find",
      "Binary Indexed Tree",
      "Segment Tree"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "The Number of Beautiful Subsets",
    "description": "You are given an array nums of positive integers and a positive integer k.\nA subset of nums is beautiful if it does not contain two integers with an absolute difference equal to k.\nReturn the number of non-empty beautiful subsets of the array nums.\nA subset of nums is an array that can be obtained by deleting some (possibly none) elements from nums. Two subsets are different if and only if the chosen indices to delete are different.\n \nExample 1:\nInput: nums = [2,4,6], k = 2\nOutput: 4\nExplanation: The beautiful subsets of the array nums are: [2], [4], [6], [2, 6].\nIt can be proved that there are only 4 beautiful subsets in the array [2,4,6].\n\nExample 2:\nInput: nums = [1], k = 1\nOutput: 1\nExplanation: The beautiful subset of the array nums is [1].\nIt can be proved that there is only 1 beautiful subset in the array [1].\n\n \nConstraints:\n\n1 <= nums.length <= 20\n1 <= nums[i], k <= 1000",
    "examples": [
      {
        "input": "Input: nums = [2,4,6], k = 2",
        "output": "Output: 4",
        "explanation": "Explanation: The beautiful subsets of the array nums are: [2], [4], [6], [2, 6]."
      },
      {
        "input": "Input: nums = [1], k = 1",
        "output": "Output: 1",
        "explanation": "Explanation: The beautiful subset of the array nums is [1]."
      }
    ],
    "topics": [
      "Array",
      "Dynamic Programming",
      "Backtracking"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Find Score of an Array After Marking All Elements",
    "description": "You are given an array nums consisting of positive integers.\nStarting with score = 0, apply the following algorithm:\n\nChoose the smallest integer of the array that is not marked. If there is a tie, choose the one with the smallest index.\nAdd the value of the chosen integer to score.\nMark the chosen element and its two adjacent elements if they exist.\nRepeat until all the array elements are marked.\n\nReturn the score you get after applying the above algorithm.\n \nExample 1:\nInput: nums = [2,1,3,4,5,2]\nOutput: 7\nExplanation: We mark the elements as follows:\n- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,1,3,4,5,2].\n- 2 is the smallest unmarked element, so we mark it and its left adjacent element: [2,1,3,4,5,2].\n- 4 is the only remaining unmarked element, so we mark it: [2,1,3,4,5,2].\nOur score is 1 + 2 + 4 = 7.\n\nExample 2:\nInput: nums = [2,3,5,1,3,2]\nOutput: 5\nExplanation: We mark the elements as follows:\n- 1 is the smallest unmarked element, so we mark it and its two adjacent elements: [2,3,5,1,3,2].\n- 2 is the smallest unmarked element, since there are two of them, we choose the left-most one, so we mark the one at index 0 and its right adjacent element: [2,3,5,1,3,2].\n- 2 is the only remaining unmarked element, so we mark it: [2,3,5,1,3,2].\nOur score is 1 + 2 + 2 = 5.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 106",
    "examples": [
      {
        "input": "Input: nums = [2,1,3,4,5,2]",
        "output": "Output: 7",
        "explanation": "Explanation: We mark the elements as follows:"
      },
      {
        "input": "Input: nums = [2,3,5,1,3,2]",
        "output": "Output: 5",
        "explanation": "Explanation: We mark the elements as follows:"
      }
    ],
    "topics": [
      "Array",
      "Sorting",
      "Heap (Priority Queue)",
      "Simulation"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Find the Maximum Divisibility Score",
    "description": "You are given two 0-indexed integer arrays nums and divisors.\nThe divisibility score of divisors[i] is the number of indices j such that nums[j] is divisible by divisors[i].\nReturn the integer divisors[i] with the maximum divisibility score. If there is more than one integer with the maximum score, return the minimum of them.\n \nExample 1:\nInput: nums = [4,7,9,3,9], divisors = [5,2,3]\nOutput: 3\nExplanation: The divisibility score for every element in divisors is:\nThe divisibility score of divisors[0] is 0 since no number in nums is divisible by 5.\nThe divisibility score of divisors[1] is 1 since nums[0] is divisible by 2.\nThe divisibility score of divisors[2] is 3 since nums[2], nums[3], and nums[4] are divisible by 3.\nSince divisors[2] has the maximum divisibility score, we return it.\n\nExample 2:\nInput: nums = [20,14,21,10], divisors = [5,7,5]\nOutput: 5\nExplanation: The divisibility score for every element in divisors is:\nThe divisibility score of divisors[0] is 2 since nums[0] and nums[3] are divisible by 5.\nThe divisibility score of divisors[1] is 2 since nums[1] and nums[2] are divisible by 7.\nThe divisibility score of divisors[2] is 2 since nums[0] and nums[3] are divisible by 5.\nSince divisors[0], divisors[1], and divisors[2] all have the maximum divisibility score, we return the minimum of them (i.e., divisors[2]).\n\nExample 3:\nInput: nums = [12], divisors = [10,16]\nOutput: 10\nExplanation: The divisibility score for every element in divisors is:\nThe divisibility score of divisors[0] is 0 since no number in nums is divisible by 10.\nThe divisibility score of divisors[1] is 0 since no number in nums is divisible by 16.\nSince divisors[0] and divisors[1] both have the maximum divisibility score, we return the minimum of them (i.e., divisors[0]).\n\n \nConstraints:\n\n1 <= nums.length, divisors.length <= 1000\n1 <= nums[i], divisors[i] <= 109",
    "examples": [
      {
        "input": "Input: nums = [4,7,9,3,9], divisors = [5,2,3]",
        "output": "Output: 3",
        "explanation": "Explanation: The divisibility score for every element in divisors is:"
      },
      {
        "input": "Input: nums = [20,14,21,10], divisors = [5,7,5]",
        "output": "Output: 5",
        "explanation": "Explanation: The divisibility score for every element in divisors is:"
      },
      {
        "input": "Input: nums = [12], divisors = [10,16]",
        "output": "Output: 10",
        "explanation": "Explanation: The divisibility score for every element in divisors is:"
      }
    ],
    "topics": [
      "Array"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Take Gifts From the Richest Pile",
    "description": "You are given an integer array gifts denoting the number of gifts in various piles. Every second, you do the following:\n\nChoose the pile with the maximum number of gifts.\nIf there is more than one pile with the maximum number of gifts, choose any.\nLeave behind the floor of the square root of the number of gifts in the pile. Take the rest of the gifts.\n\nReturn the number of gifts remaining after k seconds.\n \nExample 1:\nInput: gifts = [25,64,9,4,100], k = 4\nOutput: 29\nExplanation: \nThe gifts are taken in the following way:\n- In the first second, the last pile is chosen and 10 gifts are left behind.\n- Then the second pile is chosen and 8 gifts are left behind.\n- After that the first pile is chosen and 5 gifts are left behind.\n- Finally, the last pile is chosen again and 3 gifts are left behind.\nThe final remaining gifts are [5,8,9,4,3], so the total number of gifts remaining is 29.\n\nExample 2:\nInput: gifts = [1,1,1,1], k = 4\nOutput: 4\nExplanation: \nIn this case, regardless which pile you choose, you have to leave behind 1 gift in each pile. \nThat is, you can't take any pile with you. \nSo, the total gifts remaining are 4.\n\n \nConstraints:\n\n1 <= gifts.length <= 103\n1 <= gifts[i] <= 109\n1 <= k <= 103",
    "examples": [
      {
        "input": "Input: gifts = [25,64,9,4,100], k = 4",
        "output": "Output: 29",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: gifts = [1,1,1,1], k = 4",
        "output": "Output: 4",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Heap (Priority Queue)",
      "Simulation"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Count Vowel Strings in Ranges",
    "description": "You are given a 0-indexed array of strings words and a 2D array of integers queries.\nEach query queries[i] = [li, ri] asks us to find the number of strings present in the range li to ri (both inclusive) of words that start and end with a vowel.\nReturn an array ans of size queries.length, where ans[i] is the answer to the ith query.\nNote that the vowel letters are 'a', 'e', 'i', 'o', and 'u'.\n \nExample 1:\nInput: words = [\"aba\",\"bcb\",\"ece\",\"aa\",\"e\"], queries = [[0,2],[1,4],[1,1]]\nOutput: [2,3,0]\nExplanation: The strings starting and ending with a vowel are \"aba\", \"ece\", \"aa\" and \"e\".\nThe answer to the query [0,2] is 2 (strings \"aba\" and \"ece\").\nto query [1,4] is 3 (strings \"ece\", \"aa\", \"e\").\nto query [1,1] is 0.\nWe return [2,3,0].\n\nExample 2:\nInput: words = [\"a\",\"e\",\"i\"], queries = [[0,2],[0,1],[2,2]]\nOutput: [3,2,1]\nExplanation: Every string satisfies the conditions, so we return [3,2,1].\n \nConstraints:\n\n1 <= words.length <= 105\n1 <= words[i].length <= 40\nwords[i] consists only of lowercase English letters.\nsum(words[i].length) <= 3 * 105\n1 <= queries.length <= 105\n0 <= li <= ri < words.length",
    "examples": [
      {
        "input": "Input: words = [\"aba\",\"bcb\",\"ece\",\"aa\",\"e\"], queries = [[0,2],[1,4],[1,1]]",
        "output": "Output: [2,3,0]",
        "explanation": "Explanation: The strings starting and ending with a vowel are \"aba\", \"ece\", \"aa\" and \"e\"."
      },
      {
        "input": "Input: words = [\"a\",\"e\",\"i\"], queries = [[0,2],[0,1],[2,2]]",
        "output": "Output: [3,2,1]",
        "explanation": "Explanation: Every string satisfies the conditions, so we return [3,2,1]."
      }
    ],
    "topics": [
      "Array",
      "String",
      "Prefix Sum"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "House Robber IV",
    "description": "There are several consecutive houses along a street, each of which has some money inside. There is also a robber, who wants to steal money from the homes, but he refuses to steal from adjacent homes.\nThe capability of the robber is the maximum amount of money he steals from one house of all the houses he robbed.\nYou are given an integer array nums representing how much money is stashed in each house. More formally, the ith house from the left has nums[i] dollars.\nYou are also given an integer k, representing the minimum number of houses the robber will steal from. It is always possible to steal at least k houses.\nReturn the minimum capability of the robber out of all the possible ways to steal at least k houses.\n \nExample 1:\nInput: nums = [2,3,5,9], k = 2\nOutput: 5\nExplanation: \nThere are three ways to rob at least 2 houses:\n- Rob the houses at indices 0 and 2. Capability is max(nums[0], nums[2]) = 5.\n- Rob the houses at indices 0 and 3. Capability is max(nums[0], nums[3]) = 9.\n- Rob the houses at indices 1 and 3. Capability is max(nums[1], nums[3]) = 9.\nTherefore, we return min(5, 9, 9) = 5.\n\nExample 2:\nInput: nums = [2,7,9,3,1], k = 2\nOutput: 2\nExplanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n1 <= k <= (nums.length + 1)/2",
    "examples": [
      {
        "input": "Input: nums = [2,3,5,9], k = 2",
        "output": "Output: 5",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: nums = [2,7,9,3,1], k = 2",
        "output": "Output: 2",
        "explanation": "Explanation: There are 7 ways to rob the houses. The way which leads to minimum capability is to rob the house at index 0 and 4. Return max(nums[0], nums[4]) = 2."
      }
    ],
    "topics": [
      "Array",
      "Binary Search"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Rearranging Fruits",
    "description": "You have two fruit baskets containing n fruits each. You are given two 0-indexed integer arrays basket1 and basket2 representing the cost of fruit in each basket. You want to make both baskets equal. To do so, you can use the following operation as many times as you want:\n\nChose two indices i and j, and swap the ith fruit of basket1 with the jth fruit of basket2.\nThe cost of the swap is min(basket1[i],basket2[j]).\n\nTwo baskets are considered equal if sorting them according to the fruit cost makes them exactly the same baskets.\nReturn the minimum cost to make both the baskets equal or -1 if impossible.\n \nExample 1:\nInput: basket1 = [4,2,2,2], basket2 = [1,4,1,2]\nOutput: 1\nExplanation: Swap index 1 of basket1 with index 0 of basket2, which has cost 1. Now basket1 = [4,1,2,2] and basket2 = [2,4,1,2]. Rearranging both the arrays makes them equal.\n\nExample 2:\nInput: basket1 = [2,3,4,1], basket2 = [3,2,5,1]\nOutput: -1\nExplanation: It can be shown that it is impossible to make both the baskets equal.\n\n \nConstraints:\n\nbasket1.length == bakste2.length\n1 <= basket1.length <= 105\n1 <= basket1[i],basket2[i] <= 109",
    "examples": [
      {
        "input": "Input: basket1 = [4,2,2,2], basket2 = [1,4,1,2]",
        "output": "Output: 1",
        "explanation": "Explanation: Swap index 1 of basket1 with index 0 of basket2, which has cost 1. Now basket1 = [4,1,2,2] and basket2 = [2,4,1,2]. Rearranging both the arrays makes them equal."
      },
      {
        "input": "Input: basket1 = [2,3,4,1], basket2 = [3,2,5,1]",
        "output": "Output: -1",
        "explanation": "Explanation: It can be shown that it is impossible to make both the baskets equal."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Greedy"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Lexicographically Smallest Beautiful String",
    "description": "A string is beautiful if:\n\nIt consists of the first k letters of the English lowercase alphabet.\nIt does not contain any substring of length 2 or more which is a palindrome.\n\nYou are given a beautiful string s of length n and a positive integer k.\nReturn the lexicographically smallest string of length n, which is larger than s and is beautiful. If there is no such string, return an empty string.\nA string a is lexicographically larger than a string b (of the same length) if in the first position where a and b differ, a has a character strictly larger than the corresponding character in b.\n\nFor example, \"abcd\" is lexicographically larger than \"abcc\" because the first position they differ is at the fourth character, and d is greater than c.\n\n \nExample 1:\nInput: s = \"abcz\", k = 26\nOutput: \"abda\"\nExplanation: The string \"abda\" is beautiful and lexicographically larger than the string \"abcz\".\nIt can be proven that there is no string that is lexicographically larger than the string \"abcz\", beautiful, and lexicographically smaller than the string \"abda\".\n\nExample 2:\nInput: s = \"dc\", k = 4\nOutput: \"\"\nExplanation: It can be proven that there is no string that is lexicographically larger than the string \"dc\" and is beautiful.\n\n \nConstraints:\n\n1 <= n == s.length <= 105\n4 <= k <= 26\ns is a beautiful string.",
    "examples": [
      {
        "input": "Input: s = \"abcz\", k = 26",
        "output": "Output: \"abda\"",
        "explanation": "Explanation: The string \"abda\" is beautiful and lexicographically larger than the string \"abcz\"."
      },
      {
        "input": "Input: s = \"dc\", k = 4",
        "output": "Output: \"\"",
        "explanation": "Explanation: It can be proven that there is no string that is lexicographically larger than the string \"dc\" and is beautiful."
      }
    ],
    "topics": [
      "String",
      "Greedy"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Minimum Cost of a Path With Special Roads",
    "description": "You are given an array start where start = [startX, startY] represents your initial position (startX, startY) in a 2D space. You are also given the array target where target = [targetX, targetY] represents your target position (targetX, targetY).\nThe cost of going from a position (x1, y1) to any other position in the space (x2, y2) is |x2 - x1| + |y2 - y1|.\nThere are also some special roads. You are given a 2D array specialRoads where specialRoads[i] = [x1i, y1i, x2i, y2i, costi] indicates that the ith special road can take you from (x1i, y1i) to (x2i, y2i) with a cost equal to costi. You can use each special road any number of times.\nReturn the minimum cost required to go from (startX, startY) to (targetX, targetY).\n \nExample 1:\nInput: start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]\nOutput: 5\nExplanation: The optimal path from (1,1) to (4,5) is the following:\n- (1,1) -> (1,2). This move has a cost of |1 - 1| + |2 - 1| = 1.\n- (1,2) -> (3,3). This move uses the first special edge, the cost is 2.\n- (3,3) -> (3,4). This move has a cost of |3 - 3| + |4 - 3| = 1.\n- (3,4) -> (4,5). This move uses the second special edge, the cost is 1.\nSo the total cost is 1 + 2 + 1 + 1 = 5.\nIt can be shown that we cannot achieve a smaller total cost than 5.\n\nExample 2:\nInput: start = [3,2], target = [5,7], specialRoads = [[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]\nOutput: 7\nExplanation: It is optimal to not use any special edges and go directly from the starting to the ending position with a cost |5 - 3| + |7 - 2| = 7.\n\n \nConstraints:\n\nstart.length == target.length == 2\n1 <= startX <= targetX <= 105\n1 <= startY <= targetY <= 105\n1 <= specialRoads.length <= 200\nspecialRoads[i].length == 5\nstartX <= x1i, x2i <= targetX\nstartY <= y1i, y2i <= targetY\n1 <= costi <= 105",
    "examples": [
      {
        "input": "Input: start = [1,1], target = [4,5], specialRoads = [[1,2,3,3,2],[3,4,4,5,1]]",
        "output": "Output: 5",
        "explanation": "Explanation: The optimal path from (1,1) to (4,5) is the following:"
      },
      {
        "input": "Input: start = [3,2], target = [5,7], specialRoads = [[3,2,3,4,4],[3,3,5,5,5],[3,4,5,6,6]]",
        "output": "Output: 7",
        "explanation": "Explanation: It is optimal to not use any special edges and go directly from the starting to the ending position with a cost |5 - 3| + |7 - 2| = 7."
      }
    ],
    "topics": [
      "Array",
      "Graph",
      "Heap (Priority Queue)",
      "Shortest Path"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "First Completely Painted Row or Column",
    "description": "You are given a 0-indexed integer array arr, and an m x n integer matrix mat. arr and mat both contain all the integers in the range [1, m * n].\nGo through each index i in arr starting from index 0 and paint the cell in mat containing the integer arr[i].\nReturn the smallest index i at which either a row or a column will be completely painted in mat.\n \nExample 1:\n\nInput: arr = [1,3,4,2], mat = [[1,4],[2,3]]\nOutput: 2\nExplanation: The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2].\n\nExample 2:\n\nInput: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]\nOutput: 3\nExplanation: The second column becomes fully painted at arr[3].\n\n \nConstraints:\n\nm == mat.length\nn = mat[i].length\narr.length == m * n\n1 <= m, n <= 105\n1 <= m * n <= 105\n1 <= arr[i], mat[r][c] <= m * n\nAll the integers of arr are unique.\nAll the integers of mat are unique.",
    "examples": [
      {
        "input": "Input: arr = [1,3,4,2], mat = [[1,4],[2,3]]",
        "output": "Output: 2",
        "explanation": "Explanation: The moves are shown in order, and both the first row and second column of the matrix become fully painted at arr[2]."
      },
      {
        "input": "Input: arr = [2,8,7,4,1,3,5,6,9], mat = [[3,2,5],[1,4,6],[8,7,9]]",
        "output": "Output: 3",
        "explanation": "Explanation: The second column becomes fully painted at arr[3]."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Matrix"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Determine the Winner of a Bowling Game",
    "description": "You are given two 0-indexed integer arrays player1 and player2, that represent the number of pins that player 1 and player 2 hit in a bowling game, respectively.\nThe bowling game consists of n turns, and the number of pins in each turn is exactly 10.\nAssume a player hit xi pins in the ith turn. The value of the ith turn for the player is:\n\n2xi if the player hit 10 pins in any of the previous two turns.\nOtherwise, It is xi.\n\nThe score of the player is the sum of the values of their n turns.\nReturn\n\n1 if the score of player 1 is more than the score of player 2,\n2 if the score of player 2 is more than the score of player 1, and\n0 in case of a draw.\n\n \nExample 1:\nInput: player1 = [4,10,7,9], player2 = [6,5,2,3]\nOutput: 1\nExplanation: The score of player1 is 4 + 10 + 2*7 + 2*9 = 46.\nThe score of player2 is 6 + 5 + 2 + 3 = 16.\nScore of player1 is more than the score of player2, so, player1 is the winner, and the answer is 1.\n\nExample 2:\nInput: player1 = [3,5,7,6], player2 = [8,10,10,2]\nOutput: 2\nExplanation: The score of player1 is 3 + 5 + 7 + 6 = 21.\nThe score of player2 is 8 + 10 + 2*10 + 2*2 = 42.\nScore of player2 is more than the score of player1, so, player2 is the winner, and the answer is 2.\n\nExample 3:\nInput: player1 = [2,3], player2 = [4,1]\nOutput: 0\nExplanation: The score of player1 is 2 + 3 = 5\nThe score of player2 is 4 + 1 = 5\nThe score of player1 equals to the score of player2, so, there is a draw, and the answer is 0.\n\n\n \nConstraints:\n\nn == player1.length == player2.length\n1 <= n <= 1000\n0 <= player1[i], player2[i] <= 10",
    "examples": [
      {
        "input": "Input: player1 = [4,10,7,9], player2 = [6,5,2,3]",
        "output": "Output: 1",
        "explanation": "Explanation: The score of player1 is 4 + 10 + 2*7 + 2*9 = 46."
      },
      {
        "input": "Input: player1 = [3,5,7,6], player2 = [8,10,10,2]",
        "output": "Output: 2",
        "explanation": "Explanation: The score of player1 is 3 + 5 + 7 + 6 = 21."
      },
      {
        "input": "Input: player1 = [2,3], player2 = [4,1]",
        "output": "Output: 0",
        "explanation": "Explanation: The score of player1 is 2 + 3 = 5"
      }
    ],
    "topics": [
      "Array",
      "Simulation"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Count Increasing Quadruplets",
    "description": "Given a 0-indexed integer array nums of size n containing all numbers from 1 to n, return the number of increasing quadruplets.\nA quadruplet (i, j, k, l) is increasing if:\n\n0 <= i < j < k < l < n, and\nnums[i] < nums[k] < nums[j] < nums[l].\n\n \nExample 1:\nInput: nums = [1,3,2,4,5]\nOutput: 2\nExplanation: \n- When i = 0, j = 1, k = 2, and l = 3, nums[i] < nums[k] < nums[j] < nums[l].\n- When i = 0, j = 1, k = 2, and l = 4, nums[i] < nums[k] < nums[j] < nums[l]. \nThere are no other quadruplets, so we return 2.\n\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: 0\nExplanation: There exists only one quadruplet with i = 0, j = 1, k = 2, l = 3, but since nums[j] < nums[k], we return 0.\n\n \nConstraints:\n\n4 <= nums.length <= 4000\n1 <= nums[i] <= nums.length\nAll the integers of nums are unique. nums is a permutation.",
    "examples": [
      {
        "input": "Input: nums = [1,3,2,4,5]",
        "output": "Output: 2",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: nums = [1,2,3,4]",
        "output": "Output: 0",
        "explanation": "Explanation: There exists only one quadruplet with i = 0, j = 1, k = 2, l = 3, but since nums[j] < nums[k], we return 0."
      }
    ],
    "topics": [
      "Array",
      "Dynamic Programming",
      "Binary Indexed Tree",
      "Enumeration",
      "Prefix Sum"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Put Marbles in Bags",
    "description": "You have k bags. You are given a 0-indexed integer array weights where weights[i] is the weight of the ith marble. You are also given the integer k.\nDivide the marbles into the k bags according to the following rules:\n\nNo bag is empty.\nIf the ith marble and jth marble are in a bag, then all marbles with an index between the ith and jth indices should also be in that same bag.\nIf a bag consists of all the marbles with an index from i to j inclusively, then the cost of the bag is weights[i] + weights[j].\n\nThe score after distributing the marbles is the sum of the costs of all the k bags.\nReturn the difference between the maximum and minimum scores among marble distributions.\n \nExample 1:\nInput: weights = [1,3,5,1], k = 2\nOutput: 4\nExplanation: \nThe distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) = 6. \nThe distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1) = 10. \nThus, we return their difference 10 - 6 = 4.\n\nExample 2:\nInput: weights = [1, 3], k = 2\nOutput: 0\nExplanation: The only distribution possible is [1],[3]. \nSince both the maximal and minimal score are the same, we return 0.\n\n \nConstraints:\n\n1 <= k <= weights.length <= 105\n1 <= weights[i] <= 109",
    "examples": [
      {
        "input": "Input: weights = [1,3,5,1], k = 2",
        "output": "Output: 4",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: weights = [1, 3], k = 2",
        "output": "Output: 0",
        "explanation": "Explanation: The only distribution possible is [1],[3]. "
      }
    ],
    "topics": [
      "Array",
      "Greedy",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Count Collisions of Monkeys on a Polygon",
    "description": "There is a regular convex polygon with n vertices. The vertices are labeled from 0 to n - 1 in a clockwise direction, and each vertex has exactly one monkey. The following figure shows a convex polygon of 6 vertices.\n\nEach monkey moves simultaneously to a neighboring vertex. A neighboring vertex for a vertex i can be:\n\nthe vertex (i + 1) % n in the clockwise direction, or\nthe vertex (i - 1 + n) % n in the counter-clockwise direction.\n\nA collision happens if at least two monkeys reside on the same vertex after the movement or intersect on an edge.\nReturn the number of ways the monkeys can move so that at least one collision  happens. Since the answer may be very large, return it modulo 109 + 7.\nNote that each monkey can only move once.\n \nExample 1:\nInput: n = 3\nOutput: 6\nExplanation: There are 8 total possible movements.\nTwo ways such that they collide at some point are:\n- Monkey 1 moves in a clockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 2 collide.\n- Monkey 1 moves in an anticlockwise direction; monkey 2 moves in an anticlockwise direction; monkey 3 moves in a clockwise direction. Monkeys 1 and 3 collide.\nIt can be shown 6 total movements result in a collision.\n\nExample 2:\nInput: n = 4\nOutput: 14\nExplanation: It can be shown that there are 14 ways for the monkeys to collide.\n\n \nConstraints:\n\n3 <= n <= 109",
    "examples": [
      {
        "input": "Input: n = 3",
        "output": "Output: 6",
        "explanation": "Explanation: There are 8 total possible movements."
      },
      {
        "input": "Input: n = 4",
        "output": "Output: 14",
        "explanation": "Explanation: It can be shown that there are 14 ways for the monkeys to collide."
      }
    ],
    "topics": [
      "Math",
      "Recursion"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Count Distinct Numbers on Board",
    "description": "You are given a positive integer n, that is initially placed on a board. Every day, for 109 days, you perform the following procedure:\n\nFor each number x present on the board, find all numbers 1 <= i <= n such that x % i == 1.\nThen, place those numbers on the board.\n\nReturn the number of distinct integers present on the board after 109 days have elapsed.\nNote:\n\nOnce a number is placed on the board, it will remain on it until the end.\n% stands for the modulo operation. For example, 14 % 3 is 2.\n\n \nExample 1:\nInput: n = 5\nOutput: 4\nExplanation: Initially, 5 is present on the board. \nThe next day, 2 and 4 will be added since 5 % 2 == 1 and 5 % 4 == 1. \nAfter that day, 3 will be added to the board because 4 % 3 == 1. \nAt the end of a billion days, the distinct numbers on the board will be 2, 3, 4, and 5. \n\nExample 2:\nInput: n = 3\nOutput: 2\nExplanation: \nSince 3 % 2 == 1, 2 will be added to the board. \nAfter a billion days, the only two distinct numbers on the board are 2 and 3. \n\n \nConstraints:\n\n1 <= n <= 100",
    "examples": [
      {
        "input": "Input: n = 5",
        "output": "Output: 4",
        "explanation": "Explanation: Initially, 5 is present on the board. "
      },
      {
        "input": "Input: n = 3",
        "output": "Output: 2",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Math",
      "Simulation"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Design Graph With Shortest Path Calculator",
    "description": "There is a directed weighted graph that consists of n nodes numbered from 0 to n - 1. The edges of the graph are initially represented by the given array edges where edges[i] = [fromi, toi, edgeCosti] meaning that there is an edge from fromi to toi with the cost edgeCosti.\nImplement the Graph class:\n\nGraph(int n, int[][] edges) initializes the object with n nodes and the given edges.\naddEdge(int[] edge) adds an edge to the list of edges where edge = [from, to, edgeCost]. It is guaranteed that there is no edge between the two nodes before adding this one.\nint shortestPath(int node1, int node2) returns the minimum cost of a path from node1 to node2. If no path exists, return -1. The cost of a path is the sum of the costs of the edges in the path.\n\n \nExample 1:\n\nInput\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]\n[[4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]], [3, 2], [0, 3], [[1, 3, 4]], [0, 3]]\nOutput\n[null, 6, -1, null, 6]\n\nExplanation\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);\ng.shortestPath(3, 2); // return 6. The shortest path from 3 to 2 in the first diagram above is 3 -> 0 -> 1 -> 2 with a total cost of 3 + 2 + 1 = 6.\ng.shortestPath(0, 3); // return -1. There is no path from 0 to 3.\ng.addEdge([1, 3, 4]); // We add an edge from node 1 to node 3, and we get the second diagram above.\ng.shortestPath(0, 3); // return 6. The shortest path from 0 to 3 now is 0 -> 1 -> 3 with a total cost of 2 + 4 = 6.\n\n \nConstraints:\n\n1 <= n <= 100\n0 <= edges.length <= n * (n - 1)\nedges[i].length == edge.length == 3\n0 <= fromi, toi, from, to, node1, node2 <= n - 1\n1 <= edgeCosti, edgeCost <= 106\nThere are no repeated edges and no self-loops in the graph at any point.\nAt most 100 calls will be made for addEdge.\nAt most 100 calls will be made for shortestPath.",
    "examples": [
      {
        "input": "Input\n[\"Graph\", \"shortestPath\", \"shortestPath\", \"addEdge\", \"shortestPath\"]",
        "output": "Output\n[null, 6, -1, null, 6]",
        "explanation": "Explanation\nGraph g = new Graph(4, [[0, 2, 5], [0, 1, 2], [1, 2, 1], [3, 0, 3]]);"
      }
    ],
    "topics": [
      "Graph",
      "Design",
      "Heap (Priority Queue)",
      "Shortest Path"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Cousins in Binary Tree II",
    "description": "Given the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins' values.\nTwo nodes of a binary tree are cousins if they have the same depth with different parents.\nReturn the root of the modified tree.\nNote that the depth of a node is the number of edges in the path from the root node to it.\n \nExample 1:\n\nInput: root = [5,4,9,1,10,null,7]\nOutput: [0,0,0,7,7,null,11]\nExplanation: The diagram above shows the initial binary tree and the binary tree after changing the value of each node.\n- Node with value 5 does not have any cousins so its sum is 0.\n- Node with value 4 does not have any cousins so its sum is 0.\n- Node with value 9 does not have any cousins so its sum is 0.\n- Node with value 1 has a cousin with value 7 so its sum is 7.\n- Node with value 10 has a cousin with value 7 so its sum is 7.\n- Node with value 7 has cousins with values 1 and 10 so its sum is 11.\n\nExample 2:\n\nInput: root = [3,1,2]\nOutput: [0,0,0]\nExplanation: The diagram above shows the initial binary tree and the binary tree after changing the value of each node.\n- Node with value 3 does not have any cousins so its sum is 0.\n- Node with value 1 does not have any cousins so its sum is 0.\n- Node with value 2 does not have any cousins so its sum is 0.\n\n \nConstraints:\n\nThe number of nodes in the tree is in the range [1, 105].\n1 <= Node.val <= 104",
    "examples": [
      {
        "input": "Input: root = [5,4,9,1,10,null,7]",
        "output": "Output: [0,0,0,7,7,null,11]",
        "explanation": "Explanation: The diagram above shows the initial binary tree and the binary tree after changing the value of each node."
      },
      {
        "input": "Input: root = [3,1,2]",
        "output": "Output: [0,0,0]",
        "explanation": "Explanation: The diagram above shows the initial binary tree and the binary tree after changing the value of each node."
      }
    ],
    "topics": [
      "Hash Table",
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Binary Tree"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Find the Score of All Prefixes of an Array",
    "description": "We define the conversion array conver of an array arr as follows:\n\nconver[i] = arr[i] + max(arr[0..i]) where max(arr[0..i]) is the maximum value of arr[j] over 0 <= j <= i.\n\nWe also define the score of an array arr as the sum of the values of the conversion array of arr.\nGiven a 0-indexed integer array nums of length n, return an array ans of length n where ans[i] is the score of the prefix nums[0..i].\n \nExample 1:\nInput: nums = [2,3,7,5,10]\nOutput: [4,10,24,36,56]\nExplanation: \nFor the prefix [2], the conversion array is [4] hence the score is 4\nFor the prefix [2, 3], the conversion array is [4, 6] hence the score is 10\nFor the prefix [2, 3, 7], the conversion array is [4, 6, 14] hence the score is 24\nFor the prefix [2, 3, 7, 5], the conversion array is [4, 6, 14, 12] hence the score is 36\nFor the prefix [2, 3, 7, 5, 10], the conversion array is [4, 6, 14, 12, 20] hence the score is 56\n\nExample 2:\nInput: nums = [1,1,2,4,8,16]\nOutput: [2,4,8,16,32,64]\nExplanation: \nFor the prefix [1], the conversion array is [2] hence the score is 2\nFor the prefix [1, 1], the conversion array is [2, 2] hence the score is 4\nFor the prefix [1, 1, 2], the conversion array is [2, 2, 4] hence the score is 8\nFor the prefix [1, 1, 2, 4], the conversion array is [2, 2, 4, 8] hence the score is 16\nFor the prefix [1, 1, 2, 4, 8], the conversion array is [2, 2, 4, 8, 16] hence the score is 32\nFor the prefix [1, 1, 2, 4, 8, 16], the conversion array is [2, 2, 4, 8, 16, 32] hence the score is 64\n\n \nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109",
    "examples": [
      {
        "input": "Input: nums = [2,3,7,5,10]",
        "output": "Output: [4,10,24,36,56]",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: nums = [1,1,2,4,8,16]",
        "output": "Output: [2,4,8,16,32,64]",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Prefix Sum"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Find the Width of Columns of a Grid",
    "description": "You are given a 0-indexed m x n integer matrix grid. The width of a column is the maximum length of its integers.\n\nFor example, if grid = [[-10], [3], [12]], the width of the only column is 3 since -10 is of length 3.\n\nReturn an integer array ans of size n where ans[i] is the width of the ith column.\nThe length of an integer x with len digits is equal to len if x is non-negative, and len + 1 otherwise.\n \nExample 1:\nInput: grid = [[1],[22],[333]]\nOutput: [3]\nExplanation: In the 0th column, 333 is of length 3.\n\nExample 2:\nInput: grid = [[-15,1,3],[15,7,12],[5,6,-2]]\nOutput: [3,1,2]\nExplanation: \nIn the 0th column, only -15 is of length 3.\nIn the 1st column, all integers are of length 1. \nIn the 2nd column, both 12 and -2 are of length 2.\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 100 \n-109 <= grid[r][c] <= 109",
    "examples": [
      {
        "input": "Input: grid = [[1],[22],[333]]",
        "output": "Output: [3]",
        "explanation": "Explanation: In the 0th column, 333 is of length 3."
      },
      {
        "input": "Input: grid = [[-15,1,3],[15,7,12],[5,6,-2]]",
        "output": "Output: [3,1,2]",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Matrix"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Maximize Win From Two Segments",
    "description": "There are some prizes on the X-axis. You are given an integer array prizePositions that is sorted in non-decreasing order, where prizePositions[i] is the position of the ith prize. There could be different prizes at the same position on the line. You are also given an integer k.\nYou are allowed to select two segments with integer endpoints. The length of each segment must be k. You will collect all prizes whose position falls within at least one of the two selected segments (including the endpoints of the segments). The two selected segments may intersect.\n\nFor example if k = 2, you can choose segments [1, 3] and [2, 4], and you will win any prize i that satisfies 1 <= prizePositions[i] <= 3 or 2 <= prizePositions[i] <= 4.\n\nReturn the maximum number of prizes you can win if you choose the two segments optimally.\n \nExample 1:\nInput: prizePositions = [1,1,2,2,3,3,5], k = 2\nOutput: 7\nExplanation: In this example, you can win all 7 prizes by selecting two segments [1, 3] and [3, 5].\n\nExample 2:\nInput: prizePositions = [1,2,3,4], k = 0\nOutput: 2\nExplanation: For this example, one choice for the segments is [3, 3] and [4, 4], and you will be able to get 2 prizes. \n\n \nConstraints:\n\n1 <= prizePositions.length <= 105\n1 <= prizePositions[i] <= 109\n0 <= k <= 109 \nprizePositions is sorted in non-decreasing order.",
    "examples": [
      {
        "input": "Input: prizePositions = [1,1,2,2,3,3,5], k = 2",
        "output": "Output: 7",
        "explanation": "Explanation: In this example, you can win all 7 prizes by selecting two segments [1, 3] and [3, 5]."
      },
      {
        "input": "Input: prizePositions = [1,2,3,4], k = 0",
        "output": "Output: 2",
        "explanation": "Explanation: For this example, one choice for the segments is [3, 3] and [4, 4], and you will be able to get 2 prizes. "
      }
    ],
    "topics": [
      "Array",
      "Binary Search",
      "Sliding Window"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Shortest Cycle in a Graph",
    "description": "There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1. The edges in the graph are represented by a given 2D integer array edges, where edges[i] = [ui, vi] denotes an edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nReturn the length of the shortest cycle in the graph. If no cycle exists, return -1.\nA cycle is a path that starts and ends at the same node, and each edge in the path is used only once.\n \nExample 1:\n\nInput: n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]\nOutput: 3\nExplanation: The cycle with the smallest length is : 0 -> 1 -> 2 -> 0 \n\nExample 2:\n\nInput: n = 4, edges = [[0,1],[0,2]]\nOutput: -1\nExplanation: There are no cycles in this graph.\n\n \nConstraints:\n\n2 <= n <= 1000\n1 <= edges.length <= 1000\nedges[i].length == 2\n0 <= ui, vi < n\nui != vi\nThere are no repeated edges.",
    "examples": [
      {
        "input": "Input: n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]",
        "output": "Output: 3",
        "explanation": "Explanation: The cycle with the smallest length is : 0 -> 1 -> 2 -> 0 "
      },
      {
        "input": "Input: n = 4, edges = [[0,1],[0,2]]",
        "output": "Output: -1",
        "explanation": "Explanation: There are no cycles in this graph."
      }
    ],
    "topics": [
      "Breadth-First Search",
      "Graph"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Make K-Subarray Sums Equal",
    "description": "You are given a 0-indexed integer array arr and an integer k. The array arr is circular. In other words, the first element of the array is the next element of the last element, and the last element of the array is the previous element of the first element.\nYou can do the following operation any number of times:\n\nPick any element from arr and increase or decrease it by 1.\n\nReturn the minimum number of operations such that the sum of each subarray of length k is equal.\nA subarray is a contiguous part of the array.\n \nExample 1:\nInput: arr = [1,4,1,3], k = 2\nOutput: 1\nExplanation: we can do one operation on index 1 to make its value equal to 3.\nThe array after the operation is [1,3,1,3]\n- Subarray starts at index 0 is [1, 3], and its sum is 4 \n- Subarray starts at index 1 is [3, 1], and its sum is 4 \n- Subarray starts at index 2 is [1, 3], and its sum is 4 \n- Subarray starts at index 3 is [3, 1], and its sum is 4 \n\nExample 2:\nInput: arr = [2,5,5,7], k = 3\nOutput: 5\nExplanation: we can do three operations on index 0 to make its value equal to 5 and two operations on index 3 to make its value equal to 5.\nThe array after the operations is [5,5,5,5]\n- Subarray starts at index 0 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 1 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 2 is [5, 5, 5], and its sum is 15\n- Subarray starts at index 3 is [5, 5, 5], and its sum is 15 \n\n \nConstraints:\n\n1 <= k <= arr.length <= 105\n1 <= arr[i] <= 109",
    "examples": [
      {
        "input": "Input: arr = [1,4,1,3], k = 2",
        "output": "Output: 1",
        "explanation": "Explanation: we can do one operation on index 1 to make its value equal to 3."
      },
      {
        "input": "Input: arr = [2,5,5,7], k = 3",
        "output": "Output: 5",
        "explanation": "Explanation: we can do three operations on index 0 to make its value equal to 5 and two operations on index 3 to make its value equal to 5."
      }
    ],
    "topics": [
      "Array",
      "Math",
      "Sorting",
      "Number Theory"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Find the Substring With Maximum Cost",
    "description": "You are given a string s, a string chars of distinct characters and an integer array vals of the same length as chars.\nThe cost of the substring is the sum of the values of each character in the substring. The cost of an empty string is considered 0.\nThe value of the character is defined in the following way:\n\nIf the character is not in the string chars, then its value is its corresponding position (1-indexed) in the alphabet.\n\n\t\nFor example, the value of 'a' is 1, the value of 'b' is 2, and so on. The value of 'z' is 26.\n\n\nOtherwise, assuming i is the index where the character occurs in the string chars, then its value is vals[i].\n\nReturn the maximum cost among all substrings of the string s.\n \nExample 1:\nInput: s = \"adaa\", chars = \"d\", vals = [-1000]\nOutput: 2\nExplanation: The value of the characters \"a\" and \"d\" is 1 and -1000 respectively.\nThe substring with the maximum cost is \"aa\" and its cost is 1 + 1 = 2.\nIt can be proven that 2 is the maximum cost.\n\nExample 2:\nInput: s = \"abc\", chars = \"abc\", vals = [-1,-1,-1]\nOutput: 0\nExplanation: The value of the characters \"a\", \"b\" and \"c\" is -1, -1, and -1 respectively.\nThe substring with the maximum cost is the empty substring \"\" and its cost is 0.\nIt can be proven that 0 is the maximum cost.\n\n \nConstraints:\n\n1 <= s.length <= 105\ns consist of lowercase English letters.\n1 <= chars.length <= 26\nchars consist of distinct lowercase English letters.\nvals.length == chars.length\n-1000 <= vals[i] <= 1000",
    "examples": [
      {
        "input": "Input: s = \"adaa\", chars = \"d\", vals = [-1000]",
        "output": "Output: 2",
        "explanation": "Explanation: The value of the characters \"a\" and \"d\" is 1 and -1000 respectively."
      },
      {
        "input": "Input: s = \"abc\", chars = \"abc\", vals = [-1,-1,-1]",
        "output": "Output: 0",
        "explanation": "Explanation: The value of the characters \"a\", \"b\" and \"c\" is -1, -1, and -1 respectively."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "String",
      "Dynamic Programming"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Form Smallest Number From Two Digit Arrays",
    "description": "Given two arrays of unique digits nums1 and nums2, return the smallest number that contains at least one digit from each array.\n \nExample 1:\nInput: nums1 = [4,1,3], nums2 = [5,7]\nOutput: 15\nExplanation: The number 15 contains the digit 1 from nums1 and the digit 5 from nums2. It can be proven that 15 is the smallest number we can have.\n\nExample 2:\nInput: nums1 = [3,5,2,6], nums2 = [3,1,7]\nOutput: 3\nExplanation: The number 3 contains the digit 3 which exists in both arrays.\n\n \nConstraints:\n\n1 <= nums1.length, nums2.length <= 9\n1 <= nums1[i], nums2[i] <= 9\nAll digits in each array are unique.",
    "examples": [
      {
        "input": "Input: nums1 = [4,1,3], nums2 = [5,7]",
        "output": "Output: 15",
        "explanation": "Explanation: The number 15 contains the digit 1 from nums1 and the digit 5 from nums2. It can be proven that 15 is the smallest number we can have."
      },
      {
        "input": "Input: nums1 = [3,5,2,6], nums2 = [3,1,7]",
        "output": "Output: 3",
        "explanation": "Explanation: The number 3 contains the digit 3 which exists in both arrays."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Enumeration"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Minimum Time to Repair Cars",
    "description": "You are given an integer array ranks representing the ranks of some mechanics. ranksi is the rank of the ith mechanic. A mechanic with a rank r can repair n cars in r * n2 minutes.\nYou are also given an integer cars representing the total number of cars waiting in the garage to be repaired.\nReturn the minimum time taken to repair all the cars.\nNote: All the mechanics can repair the cars simultaneously.\n \nExample 1:\nInput: ranks = [4,2,3,1], cars = 10\nOutput: 16\nExplanation: \n- The first mechanic will repair two cars. The time required is 4 * 2 * 2 = 16 minutes.\n- The second mechanic will repair two cars. The time required is 2 * 2 * 2 = 8 minutes.\n- The third mechanic will repair two cars. The time required is 3 * 2 * 2 = 12 minutes.\n- The fourth mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.\nIt can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​\n\nExample 2:\nInput: ranks = [5,1,8], cars = 6\nOutput: 16\nExplanation: \n- The first mechanic will repair one car. The time required is 5 * 1 * 1 = 5 minutes.\n- The second mechanic will repair four cars. The time required is 1 * 4 * 4 = 16 minutes.\n- The third mechanic will repair one car. The time required is 8 * 1 * 1 = 8 minutes.\nIt can be proved that the cars cannot be repaired in less than 16 minutes.​​​​​\n\n \nConstraints:\n\n1 <= ranks.length <= 105\n1 <= ranks[i] <= 100\n1 <= cars <= 106",
    "examples": [
      {
        "input": "Input: ranks = [4,2,3,1], cars = 10",
        "output": "Output: 16",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: ranks = [5,1,8], cars = 6",
        "output": "Output: 16",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Binary Search"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Maximize Greatness of an Array",
    "description": "You are given a 0-indexed integer array nums. You are allowed to permute nums into a new array perm of your choosing.\nWe define the greatness of nums be the number of indices 0 <= i < nums.length for which perm[i] > nums[i].\nReturn the maximum possible greatness you can achieve after permuting nums.\n \nExample 1:\nInput: nums = [1,3,5,2,1,3,1]\nOutput: 4\nExplanation: One of the optimal rearrangements is perm = [2,5,1,3,3,1,1].\nAt indices = 0, 1, 3, and 4, perm[i] > nums[i]. Hence, we return 4.\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: 3\nExplanation: We can prove the optimal perm is [2,3,4,1].\nAt indices = 0, 1, and 2, perm[i] > nums[i]. Hence, we return 3.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 109",
    "examples": [
      {
        "input": "Input: nums = [1,3,5,2,1,3,1]",
        "output": "Output: 4",
        "explanation": "Explanation: One of the optimal rearrangements is perm = [2,5,1,3,3,1,1]."
      },
      {
        "input": "Input: nums = [1,2,3,4]",
        "output": "Output: 3",
        "explanation": "Explanation: We can prove the optimal perm is [2,3,4,1]."
      }
    ],
    "topics": [
      "Array",
      "Two Pointers",
      "Greedy",
      "Sorting"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Distribute Money to Maximum Children",
    "description": "You are given an integer money denoting the amount of money (in dollars) that you have and another integer children denoting the number of children that you must distribute the money to.\nYou have to distribute the money according to the following rules:\n\nAll money must be distributed.\nEveryone must receive at least 1 dollar.\nNobody receives 4 dollars.\n\nReturn the maximum number of children who may receive exactly 8 dollars if you distribute the money according to the aforementioned rules. If there is no way to distribute the money, return -1.\n \nExample 1:\nInput: money = 20, children = 3\nOutput: 1\nExplanation: \nThe maximum number of children with 8 dollars will be 1. One of the ways to distribute the money is:\n- 8 dollars to the first child.\n- 9 dollars to the second child. \n- 3 dollars to the third child.\nIt can be proven that no distribution exists such that number of children getting 8 dollars is greater than 1.\n\nExample 2:\nInput: money = 16, children = 2\nOutput: 2\nExplanation: Each child can be given 8 dollars.\n\n \nConstraints:\n\n1 <= money <= 200\n2 <= children <= 30",
    "examples": [
      {
        "input": "Input: money = 20, children = 3",
        "output": "Output: 1",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: money = 16, children = 2",
        "output": "Output: 2",
        "explanation": "Explanation: Each child can be given 8 dollars."
      }
    ],
    "topics": [
      "Math",
      "Greedy"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Check Knight Tour Configuration",
    "description": "There is a knight on an n x n chessboard. In a valid configuration, the knight starts at the top-left cell of the board and visits every cell on the board exactly once.\nYou are given an n x n integer matrix grid consisting of distinct integers from the range [0, n * n - 1] where grid[row][col] indicates that the cell (row, col) is the grid[row][col]th cell that the knight visited. The moves are 0-indexed.\nReturn true if grid represents a valid configuration of the knight's movements or false otherwise.\nNote that a valid knight move consists of moving two squares vertically and one square horizontally, or two squares horizontally and one square vertically. The figure below illustrates all the possible eight moves of a knight from some cell.\n\n \nExample 1:\n\nInput: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]\nOutput: true\nExplanation: The above diagram represents the grid. It can be shown that it is a valid configuration.\n\nExample 2:\n\nInput: grid = [[0,3,6],[5,8,1],[2,7,4]]\nOutput: false\nExplanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move.\n\n \nConstraints:\n\nn == grid.length == grid[i].length\n3 <= n <= 7\n0 <= grid[row][col] < n * n\nAll integers in grid are unique.",
    "examples": [
      {
        "input": "Input: grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]",
        "output": "Output: true",
        "explanation": "Explanation: The above diagram represents the grid. It can be shown that it is a valid configuration."
      },
      {
        "input": "Input: grid = [[0,3,6],[5,8,1],[2,7,4]]",
        "output": "Output: false",
        "explanation": "Explanation: The above diagram represents the grid. The 8th move of the knight is not valid considering its position after the 7th move."
      }
    ],
    "topics": [
      "Array",
      "Depth-First Search",
      "Breadth-First Search",
      "Matrix",
      "Simulation"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Smallest Missing Non-negative Integer After Operations",
    "description": "You are given a 0-indexed integer array nums and an integer value.\nIn one operation, you can add or subtract value from any element of nums.\n\nFor example, if nums = [1,2,3] and value = 2, you can choose to subtract value from nums[0] to make nums = [-1,2,3].\n\nThe MEX (minimum excluded) of an array is the smallest missing non-negative integer in it.\n\nFor example, the MEX of [-1,2,3] is 0 while the MEX of [1,0,3] is 2.\n\nReturn the maximum MEX of nums after applying the mentioned operation any number of times.\n \nExample 1:\nInput: nums = [1,-10,7,13,6,8], value = 5\nOutput: 4\nExplanation: One can achieve this result by applying the following operations:\n- Add value to nums[1] twice to make nums = [1,0,7,13,6,8]\n- Subtract value from nums[2] once to make nums = [1,0,2,13,6,8]\n- Subtract value from nums[3] twice to make nums = [1,0,2,3,6,8]\nThe MEX of nums is 4. It can be shown that 4 is the maximum MEX we can achieve.\n\nExample 2:\nInput: nums = [1,-10,7,13,6,8], value = 7\nOutput: 2\nExplanation: One can achieve this result by applying the following operation:\n- subtract value from nums[2] once to make nums = [1,-10,0,13,6,8]\nThe MEX of nums is 2. It can be shown that 2 is the maximum MEX we can achieve.\n\n \nConstraints:\n\n1 <= nums.length, value <= 105\n-109 <= nums[i] <= 109",
    "examples": [
      {
        "input": "Input: nums = [1,-10,7,13,6,8], value = 5",
        "output": "Output: 4",
        "explanation": "Explanation: One can achieve this result by applying the following operations:"
      },
      {
        "input": "Input: nums = [1,-10,7,13,6,8], value = 7",
        "output": "Output: 2",
        "explanation": "Explanation: One can achieve this result by applying the following operation:"
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Math",
      "Greedy"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Number of Even and Odd Bits",
    "description": "You are given a positive integer n.\nLet even denote the number of even indices in the binary representation of n (0-indexed) with value 1.\nLet odd denote the number of odd indices in the binary representation of n (0-indexed) with value 1.\nReturn an integer array answer where answer = [even, odd].\n \nExample 1:\nInput: n = 17\nOutput: [2,0]\nExplanation: The binary representation of 17 is 10001. \nIt contains 1 on the 0th and 4th indices. \nThere are 2 even and 0 odd indices.\n\nExample 2:\nInput: n = 2\nOutput: [0,1]\nExplanation: The binary representation of 2 is 10.\nIt contains 1 on the 1st index. \nThere are 0 even and 1 odd indices.\n\n \nConstraints:\n\n1 <= n <= 1000",
    "examples": [
      {
        "input": "Input: n = 17",
        "output": "Output: [2,0]",
        "explanation": "Explanation: The binary representation of 17 is 10001. "
      },
      {
        "input": "Input: n = 2",
        "output": "Output: [0,1]",
        "explanation": "Explanation: The binary representation of 2 is 10."
      }
    ],
    "topics": [
      "Bit Manipulation"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Minimum Time to Complete All Tasks",
    "description": "There is a computer that can run an unlimited number of tasks at the same time. You are given a 2D integer array tasks where tasks[i] = [starti, endi, durationi] indicates that the ith task should run for a total of durationi seconds (not necessarily continuous) within the inclusive time range [starti, endi].\nYou may turn on the computer only when it needs to run a task. You can also turn it off if it is idle.\nReturn the minimum time during which the computer should be turned on to complete all tasks.\n \nExample 1:\nInput: tasks = [[2,3,1],[4,5,1],[1,5,2]]\nOutput: 2\nExplanation: \n- The first task can be run in the inclusive time range [2, 2].\n- The second task can be run in the inclusive time range [5, 5].\n- The third task can be run in the two inclusive time ranges [2, 2] and [5, 5].\nThe computer will be on for a total of 2 seconds.\n\nExample 2:\nInput: tasks = [[1,3,2],[2,5,3],[5,6,2]]\nOutput: 4\nExplanation: \n- The first task can be run in the inclusive time range [2, 3].\n- The second task can be run in the inclusive time ranges [2, 3] and [5, 5].\n- The third task can be run in the two inclusive time range [5, 6].\nThe computer will be on for a total of 4 seconds.\n\n \nConstraints:\n\n1 <= tasks.length <= 2000\ntasks[i].length == 3\n1 <= starti, endi <= 2000\n1 <= durationi <= endi - starti + 1",
    "examples": [
      {
        "input": "Input: tasks = [[2,3,1],[4,5,1],[1,5,2]]",
        "output": "Output: 2",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: tasks = [[1,3,2],[2,5,3],[5,6,2]]",
        "output": "Output: 4",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Binary Search",
      "Stack",
      "Greedy",
      "Sorting"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Count the Number of Beautiful Subarrays",
    "description": "You are given a 0-indexed integer array nums. In one operation, you can:\n\nChoose two different indices i and j such that 0 <= i, j < nums.length.\nChoose a non-negative integer k such that the kth bit (0-indexed) in the binary representation of nums[i] and nums[j] is 1.\nSubtract 2k from nums[i] and nums[j].\n\nA subarray is beautiful if it is possible to make all of its elements equal to 0 after applying the above operation any number of times.\nReturn the number of beautiful subarrays in the array nums.\nA subarray is a contiguous non-empty sequence of elements within an array.\n \nExample 1:\nInput: nums = [4,3,1,2,4]\nOutput: 2\nExplanation: There are 2 beautiful subarrays in nums: [4,3,1,2,4] and [4,3,1,2,4].\n- We can make all elements in the subarray [3,1,2] equal to 0 in the following way:\n  - Choose [3, 1, 2] and k = 1. Subtract 21 from both numbers. The subarray becomes [1, 1, 0].\n  - Choose [1, 1, 0] and k = 0. Subtract 20 from both numbers. The subarray becomes [0, 0, 0].\n- We can make all elements in the subarray [4,3,1,2,4] equal to 0 in the following way:\n  - Choose [4, 3, 1, 2, 4] and k = 2. Subtract 22 from both numbers. The subarray becomes [0, 3, 1, 2, 0].\n  - Choose [0, 3, 1, 2, 0] and k = 0. Subtract 20 from both numbers. The subarray becomes [0, 2, 0, 2, 0].\n  - Choose [0, 2, 0, 2, 0] and k = 1. Subtract 21 from both numbers. The subarray becomes [0, 0, 0, 0, 0].\n\nExample 2:\nInput: nums = [1,10,4]\nOutput: 0\nExplanation: There are no beautiful subarrays in nums.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n0 <= nums[i] <= 106",
    "examples": [
      {
        "input": "Input: nums = [4,3,1,2,4]",
        "output": "Output: 2",
        "explanation": "Explanation: There are 2 beautiful subarrays in nums: [4,3,1,2,4] and [4,3,1,2,4]."
      },
      {
        "input": "Input: nums = [1,10,4]",
        "output": "Output: 0",
        "explanation": "Explanation: There are no beautiful subarrays in nums."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Bit Manipulation",
      "Prefix Sum"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Rearrange Array to Maximize Prefix Score",
    "description": "You are given a 0-indexed integer array nums. You can rearrange the elements of nums to any order (including the given order).\nLet prefix be the array containing the prefix sums of nums after rearranging it. In other words, prefix[i] is the sum of the elements from 0 to i in nums after rearranging it. The score of nums is the number of positive integers in the array prefix.\nReturn the maximum score you can achieve.\n \nExample 1:\nInput: nums = [2,-1,0,1,-3,3,-3]\nOutput: 6\nExplanation: We can rearrange the array into nums = [2,3,1,-1,-3,0,-3].\nprefix = [2,5,6,5,2,2,-1], so the score is 6.\nIt can be shown that 6 is the maximum score we can obtain.\n\nExample 2:\nInput: nums = [-2,-3,0]\nOutput: 0\nExplanation: Any rearrangement of the array will result in a score of 0.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n-106 <= nums[i] <= 106",
    "examples": [
      {
        "input": "Input: nums = [2,-1,0,1,-3,3,-3]",
        "output": "Output: 6",
        "explanation": "Explanation: We can rearrange the array into nums = [2,3,1,-1,-3,0,-3]."
      },
      {
        "input": "Input: nums = [-2,-3,0]",
        "output": "Output: 0",
        "explanation": "Explanation: Any rearrangement of the array will result in a score of 0."
      }
    ],
    "topics": [
      "Array",
      "Greedy",
      "Sorting",
      "Prefix Sum"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Count the Number of Vowel Strings in Range",
    "description": "You are given a 0-indexed array of string words and two integers left and right.\nA string is called a vowel string if it starts with a vowel character and ends with a vowel character where vowel characters are 'a', 'e', 'i', 'o', and 'u'.\nReturn the number of vowel strings words[i] where i belongs to the inclusive range [left, right].\n \nExample 1:\nInput: words = [\"are\",\"amy\",\"u\"], left = 0, right = 2\nOutput: 2\nExplanation: \n- \"are\" is a vowel string because it starts with 'a' and ends with 'e'.\n- \"amy\" is not a vowel string because it does not end with a vowel.\n- \"u\" is a vowel string because it starts with 'u' and ends with 'u'.\nThe number of vowel strings in the mentioned range is 2.\n\nExample 2:\nInput: words = [\"hey\",\"aeo\",\"mu\",\"ooo\",\"artro\"], left = 1, right = 4\nOutput: 3\nExplanation: \n- \"aeo\" is a vowel string because it starts with 'a' and ends with 'o'.\n- \"mu\" is not a vowel string because it does not start with a vowel.\n- \"ooo\" is a vowel string because it starts with 'o' and ends with 'o'.\n- \"artro\" is a vowel string because it starts with 'a' and ends with 'o'.\nThe number of vowel strings in the mentioned range is 3.\n\n \nConstraints:\n\n1 <= words.length <= 1000\n1 <= words[i].length <= 10\nwords[i] consists of only lowercase English letters.\n0 <= left <= right < words.length",
    "examples": [
      {
        "input": "Input: words = [\"are\",\"amy\",\"u\"], left = 0, right = 2",
        "output": "Output: 2",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: words = [\"hey\",\"aeo\",\"mu\",\"ooo\",\"artro\"], left = 1, right = 4",
        "output": "Output: 3",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "String"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Count Number of Possible Root Nodes",
    "description": "Alice has an undirected tree with n nodes labeled from 0 to n - 1. The tree is represented as a 2D integer array edges of length n - 1 where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nAlice wants Bob to find the root of the tree. She allows Bob to make several guesses about her tree. In one guess, he does the following:\n\nChooses two distinct integers u and v such that there exists an edge [u, v] in the tree.\nHe tells Alice that u is the parent of v in the tree.\n\nBob's guesses are represented by a 2D integer array guesses where guesses[j] = [uj, vj] indicates Bob guessed uj to be the parent of vj.\nAlice being lazy, does not reply to each of Bob's guesses, but just says that at least k of his guesses are true.\nGiven the 2D integer arrays edges, guesses and the integer k, return the number of possible nodes that can be the root of Alice's tree. If there is no such tree, return 0.\n \nExample 1:\n\nInput: edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3\nOutput: 3\nExplanation: \nRoot = 0, correct guesses = [1,3], [0,1], [2,4]\nRoot = 1, correct guesses = [1,3], [1,0], [2,4]\nRoot = 2, correct guesses = [1,3], [1,0], [2,4]\nRoot = 3, correct guesses = [1,0], [2,4]\nRoot = 4, correct guesses = [1,3], [1,0]\nConsidering 0, 1, or 2 as root node leads to 3 correct guesses.\n\n\nExample 2:\n\nInput: edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1\nOutput: 5\nExplanation: \nRoot = 0, correct guesses = [3,4]\nRoot = 1, correct guesses = [1,0], [3,4]\nRoot = 2, correct guesses = [1,0], [2,1], [3,4]\nRoot = 3, correct guesses = [1,0], [2,1], [3,2], [3,4]\nRoot = 4, correct guesses = [1,0], [2,1], [3,2]\nConsidering any node as root will give at least 1 correct guess. \n\n\n \nConstraints:\n\nedges.length == n - 1\n2 <= n <= 105\n1 <= guesses.length <= 105\n0 <= ai, bi, uj, vj <= n - 1\nai != bi\nuj != vj\nedges represents a valid tree.\nguesses[j] is an edge of the tree.\nguesses is unique.\n0 <= k <= guesses.length",
    "examples": [
      {
        "input": "Input: edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3",
        "output": "Output: 3",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1",
        "output": "Output: 5",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Hash Table",
      "Dynamic Programming",
      "Tree",
      "Depth-First Search"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Count Ways to Group Overlapping Ranges",
    "description": "You are given a 2D integer array ranges where ranges[i] = [starti, endi] denotes that all integers between starti and endi (both inclusive) are contained in the ith range.\nYou are to split ranges into two (possibly empty) groups such that:\n\nEach range belongs to exactly one group.\nAny two overlapping ranges must belong to the same group.\n\nTwo ranges are said to be overlapping if there exists at least one integer that is present in both ranges.\n\nFor example, [1, 3] and [2, 5] are overlapping because 2 and 3 occur in both ranges.\n\nReturn the total number of ways to split ranges into two groups. Since the answer may be very large, return it modulo 109 + 7.\n \nExample 1:\nInput: ranges = [[6,10],[5,15]]\nOutput: 2\nExplanation: \nThe two ranges are overlapping, so they must be in the same group.\nThus, there are two possible ways:\n- Put both the ranges together in group 1.\n- Put both the ranges together in group 2.\n\nExample 2:\nInput: ranges = [[1,3],[10,20],[2,5],[4,8]]\nOutput: 4\nExplanation: \nRanges [1,3], and [2,5] are overlapping. So, they must be in the same group.\nAgain, ranges [2,5] and [4,8] are also overlapping. So, they must also be in the same group. \nThus, there are four possible ways to group them:\n- All the ranges in group 1.\n- All the ranges in group 2.\n- Ranges [1,3], [2,5], and [4,8] in group 1 and [10,20] in group 2.\n- Ranges [1,3], [2,5], and [4,8] in group 2 and [10,20] in group 1.\n\n \nConstraints:\n\n1 <= ranges.length <= 105\nranges[i].length == 2\n0 <= starti <= endi <= 109",
    "examples": [
      {
        "input": "Input: ranges = [[6,10],[5,15]]",
        "output": "Output: 2",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: ranges = [[1,3],[10,20],[2,5],[4,8]]",
        "output": "Output: 4",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Sorting"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Split With Minimum Sum",
    "description": "Given a positive integer num, split it into two non-negative integers num1 and num2 such that:\n\nThe concatenation of num1 and num2 is a permutation of num.\n\n\t\nIn other words, the sum of the number of occurrences of each digit in num1 and num2 is equal to the number of occurrences of that digit in num.\n\n\nnum1 and num2 can contain leading zeros.\n\nReturn the minimum possible sum of num1 and num2.\nNotes:\n\nIt is guaranteed that num does not contain any leading zeros.\nThe order of occurrence of the digits in num1 and num2 may differ from the order of occurrence of num.\n\n \nExample 1:\nInput: num = 4325\nOutput: 59\nExplanation: We can split 4325 so that num1 is 24 and num2 is 35, giving a sum of 59. We can prove that 59 is indeed the minimal possible sum.\n\nExample 2:\nInput: num = 687\nOutput: 75\nExplanation: We can split 687 so that num1 is 68 and num2 is 7, which would give an optimal sum of 75.\n\n \nConstraints:\n\n10 <= num <= 109",
    "examples": [
      {
        "input": "Input: num = 4325",
        "output": "Output: 59",
        "explanation": "Explanation: We can split 4325 so that num1 is 24 and num2 is 35, giving a sum of 59. We can prove that 59 is indeed the minimal possible sum."
      },
      {
        "input": "Input: num = 687",
        "output": "Output: 75",
        "explanation": "Explanation: We can split 687 so that num1 is 68 and num2 is 7, which would give an optimal sum of 75."
      }
    ],
    "topics": [
      "Math",
      "Greedy",
      "Sorting"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Count Total Number of Colored Cells",
    "description": "There exists an infinitely large two-dimensional grid of uncolored unit cells. You are given a positive integer n, indicating that you must do the following routine for n minutes:\n\nAt the first minute, color any arbitrary unit cell blue.\nEvery minute thereafter, color blue every uncolored cell that touches a blue cell.\n\nBelow is a pictorial representation of the state of the grid after minutes 1, 2, and 3.\n\nReturn the number of colored cells at the end of n minutes.\n \nExample 1:\nInput: n = 1\nOutput: 1\nExplanation: After 1 minute, there is only 1 blue cell, so we return 1.\n\nExample 2:\nInput: n = 2\nOutput: 5\nExplanation: After 2 minutes, there are 4 colored cells on the boundary and 1 in the center, so we return 5. \n\n \nConstraints:\n\n1 <= n <= 105",
    "examples": [
      {
        "input": "Input: n = 1",
        "output": "Output: 1",
        "explanation": "Explanation: After 1 minute, there is only 1 blue cell, so we return 1."
      },
      {
        "input": "Input: n = 2",
        "output": "Output: 5",
        "explanation": "Explanation: After 2 minutes, there are 4 colored cells on the boundary and 1 in the center, so we return 5. "
      }
    ],
    "topics": [
      "Math"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Number of Ways to Earn Points",
    "description": "There is a test that has n types of questions. You are given an integer target and a 0-indexed 2D integer array types where types[i] = [counti, marksi] indicates that there are counti questions of the ith type, and each one of them is worth marksi points.\n\n\nReturn the number of ways you can earn exactly target points in the exam. Since the answer may be too large, return it modulo 109 + 7.\nNote that questions of the same type are indistinguishable.\n\nFor example, if there are 3 questions of the same type, then solving the 1st and 2nd questions is the same as solving the 1st and 3rd questions, or the 2nd and 3rd questions.\n\n \nExample 1:\nInput: target = 6, types = [[6,1],[3,2],[2,3]]\nOutput: 7\nExplanation: You can earn 6 points in one of the seven ways:\n- Solve 6 questions of the 0th type: 1 + 1 + 1 + 1 + 1 + 1 = 6\n- Solve 4 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 1 + 2 = 6\n- Solve 2 questions of the 0th type and 2 questions of the 1st type: 1 + 1 + 2 + 2 = 6\n- Solve 3 questions of the 0th type and 1 question of the 2nd type: 1 + 1 + 1 + 3 = 6\n- Solve 1 question of the 0th type, 1 question of the 1st type and 1 question of the 2nd type: 1 + 2 + 3 = 6\n- Solve 3 questions of the 1st type: 2 + 2 + 2 = 6\n- Solve 2 questions of the 2nd type: 3 + 3 = 6\n\nExample 2:\nInput: target = 5, types = [[50,1],[50,2],[50,5]]\nOutput: 4\nExplanation: You can earn 5 points in one of the four ways:\n- Solve 5 questions of the 0th type: 1 + 1 + 1 + 1 + 1 = 5\n- Solve 3 questions of the 0th type and 1 question of the 1st type: 1 + 1 + 1 + 2 = 5\n- Solve 1 questions of the 0th type and 2 questions of the 1st type: 1 + 2 + 2 = 5\n- Solve 1 question of the 2nd type: 5\n\nExample 3:\nInput: target = 18, types = [[6,1],[3,2],[2,3]]\nOutput: 1\nExplanation: You can only earn 18 points by answering all questions.\n\n \nConstraints:\n\n1 <= target <= 1000\nn == types.length\n1 <= n <= 50\ntypes[i].length == 2\n1 <= counti, marksi <= 50",
    "examples": [
      {
        "input": "Input: target = 6, types = [[6,1],[3,2],[2,3]]",
        "output": "Output: 7",
        "explanation": "Explanation: You can earn 6 points in one of the seven ways:"
      },
      {
        "input": "Input: target = 5, types = [[50,1],[50,2],[50,5]]",
        "output": "Output: 4",
        "explanation": "Explanation: You can earn 5 points in one of the four ways:"
      },
      {
        "input": "Input: target = 18, types = [[6,1],[3,2],[2,3]]",
        "output": "Output: 1",
        "explanation": "Explanation: You can only earn 18 points by answering all questions."
      }
    ],
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Split the Array to Make Coprime Products",
    "description": "You are given a 0-indexed integer array nums of length n.\nA split at an index i where 0 <= i <= n - 2 is called valid if the product of the first i + 1 elements and the product of the remaining elements are coprime.\n\nFor example, if nums = [2, 3, 3], then a split at the index i = 0 is valid because 2 and 9 are coprime, while a split at the index i = 1 is not valid because 6 and 3 are not coprime. A split at the index i = 2 is not valid because i == n - 1.\n\nReturn the smallest index i at which the array can be split validly or -1 if there is no such split.\nTwo values val1 and val2 are coprime if gcd(val1, val2) == 1 where gcd(val1, val2) is the greatest common divisor of val1 and val2.\n \nExample 1:\n\nInput: nums = [4,7,8,15,3,5]\nOutput: 2\nExplanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThe only valid split is at index 2.\n\nExample 2:\n\nInput: nums = [4,7,15,8,3,5]\nOutput: -1\nExplanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i.\nThere is no valid split.\n\n \nConstraints:\n\nn == nums.length\n1 <= n <= 104\n1 <= nums[i] <= 106",
    "examples": [
      {
        "input": "Input: nums = [4,7,8,15,3,5]",
        "output": "Output: 2",
        "explanation": "Explanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i."
      },
      {
        "input": "Input: nums = [4,7,15,8,3,5]",
        "output": "Output: -1",
        "explanation": "Explanation: The table above shows the values of the product of the first i + 1 elements, the remaining elements, and their gcd at each index i."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Math",
      "Number Theory"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Kth Largest Sum in a Binary Tree",
    "description": "You are given the root of a binary tree and a positive integer k.\nThe level sum in the tree is the sum of the values of the nodes that are on the same level.\nReturn the kth largest level sum in the tree (not necessarily distinct). If there are fewer than k levels in the tree, return -1.\nNote that two nodes are on the same level if they have the same distance from the root.\n \nExample 1:\n\nInput: root = [5,8,9,2,1,3,7,4,6], k = 2\nOutput: 13\nExplanation: The level sums are the following:\n- Level 1: 5.\n- Level 2: 8 + 9 = 17.\n- Level 3: 2 + 1 + 3 + 7 = 13.\n- Level 4: 4 + 6 = 10.\nThe 2nd largest level sum is 13.\n\nExample 2:\n\nInput: root = [1,2,null,3], k = 1\nOutput: 3\nExplanation: The largest level sum is 3.\n\n \nConstraints:\n\nThe number of nodes in the tree is n.\n2 <= n <= 105\n1 <= Node.val <= 106\n1 <= k <= n",
    "examples": [
      {
        "input": "Input: root = [5,8,9,2,1,3,7,4,6], k = 2",
        "output": "Output: 13",
        "explanation": "Explanation: The level sums are the following:"
      },
      {
        "input": "Input: root = [1,2,null,3], k = 1",
        "output": "Output: 3",
        "explanation": "Explanation: The largest level sum is 3."
      }
    ],
    "topics": [
      "Binary Search",
      "Tree",
      "Breadth-First Search"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Pass the Pillow",
    "description": "There are n people standing in a line labeled from 1 to n. The first person in the line is holding a pillow initially. Every second, the person holding the pillow passes it to the next person standing in the line. Once the pillow reaches the end of the line, the direction changes, and people continue passing the pillow in the opposite direction.\n\nFor example, once the pillow reaches the nth person they pass it to the n - 1th person, then to the n - 2th person and so on.\n\nGiven the two positive integers n and time, return the index of the person holding the pillow after time seconds.\n \nExample 1:\nInput: n = 4, time = 5\nOutput: 2\nExplanation: People pass the pillow in the following way: 1 -> 2 -> 3 -> 4 -> 3 -> 2.\nAfer five seconds, the pillow is given to the 2nd person.\n\nExample 2:\nInput: n = 3, time = 2\nOutput: 3\nExplanation: People pass the pillow in the following way: 1 -> 2 -> 3.\nAfer two seconds, the pillow is given to the 3rd person.\n\n \nConstraints:\n\n2 <= n <= 1000\n1 <= time <= 1000",
    "examples": [
      {
        "input": "Input: n = 4, time = 5",
        "output": "Output: 2",
        "explanation": "Explanation: People pass the pillow in the following way: 1 -> 2 -> 3 -> 4 -> 3 -> 2."
      },
      {
        "input": "Input: n = 3, time = 2",
        "output": "Output: 3",
        "explanation": "Explanation: People pass the pillow in the following way: 1 -> 2 -> 3."
      }
    ],
    "topics": [
      "Math",
      "Simulation"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Time to Cross a Bridge",
    "description": "There are k workers who want to move n boxes from an old warehouse to a new one. You are given the two integers n and k, and a 2D integer array time of size k x 4 where time[i] = [leftToRighti, pickOldi, rightToLefti, putNewi].\nThe warehouses are separated by a river and connected by a bridge. The old warehouse is on the right bank of the river, and the new warehouse is on the left bank of the river. Initially, all k workers are waiting on the left side of the bridge. To move the boxes, the ith worker (0-indexed) can :\n\nCross the bridge from the left bank (new warehouse) to the right bank (old warehouse) in leftToRighti minutes.\nPick a box from the old warehouse and return to the bridge in pickOldi minutes. Different workers can pick up their boxes simultaneously.\nCross the bridge from the right bank (old warehouse) to the left bank (new warehouse) in rightToLefti minutes.\nPut the box in the new warehouse and return to the bridge in putNewi minutes. Different workers can put their boxes simultaneously.\n\nA worker i is less efficient than a worker j if either condition is met:\n\nleftToRighti + rightToLefti > leftToRightj + rightToLeftj\nleftToRighti + rightToLefti == leftToRightj + rightToLeftj and i > j\n\nThe following rules regulate the movement of the workers through the bridge :\n\nIf a worker x reaches the bridge while another worker y is crossing the bridge, x waits at their side of the bridge.\nIf the bridge is free, the worker waiting on the right side of the bridge gets to cross the bridge. If more than one worker is waiting on the right side, the one with the lowest efficiency crosses first.\nIf the bridge is free and no worker is waiting on the right side, and at least one box remains at the old warehouse, the worker on the left side of the river gets to cross the bridge. If more than one worker is waiting on the left side, the one with the lowest efficiency crosses first.\n\nReturn the instance of time at which the last worker reaches the left bank of the river after all n boxes have been put in the new warehouse.\n \nExample 1:\nInput: n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]\nOutput: 6\nExplanation: \nFrom 0 to 1: worker 2 crosses the bridge from the left bank to the right bank.\nFrom 1 to 2: worker 2 picks up a box from the old warehouse.\nFrom 2 to 6: worker 2 crosses the bridge from the right bank to the left bank.\nFrom 6 to 7: worker 2 puts a box at the new warehouse.\nThe whole process ends after 7 minutes. We return 6 because the problem asks for the instance of time at which the last worker reaches the left bank.\n\nExample 2:\nInput: n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]\nOutput: 50\nExplanation: \nFrom 0  to 10: worker 1 crosses the bridge from the left bank to the right bank.\nFrom 10 to 20: worker 1 picks up a box from the old warehouse.\nFrom 10 to 11: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 11 to 20: worker 0 picks up a box from the old warehouse.\nFrom 20 to 30: worker 1 crosses the bridge from the right bank to the left bank.\nFrom 30 to 40: worker 1 puts a box at the new warehouse.\nFrom 30 to 31: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 31 to 39: worker 0 puts a box at the new warehouse.\nFrom 39 to 40: worker 0 crosses the bridge from the left bank to the right bank.\nFrom 40 to 49: worker 0 picks up a box from the old warehouse.\nFrom 49 to 50: worker 0 crosses the bridge from the right bank to the left bank.\nFrom 50 to 58: worker 0 puts a box at the new warehouse.\nThe whole process ends after 58 minutes. We return 50 because the problem asks for the instance of time at which the last worker reaches the left bank.\n\n \nConstraints:\n\n1 <= n, k <= 104\ntime.length == k\ntime[i].length == 4\n1 <= leftToRighti, pickOldi, rightToLefti, putNewi <= 1000",
    "examples": [
      {
        "input": "Input: n = 1, k = 3, time = [[1,1,2,1],[1,1,3,1],[1,1,4,1]]",
        "output": "Output: 6",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: n = 3, k = 2, time = [[1,9,1,8],[10,10,10,10]]",
        "output": "Output: 50",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Heap (Priority Queue)",
      "Simulation"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Disconnect Path in a Binary Matrix by at Most One Flip",
    "description": "You are given a 0-indexed m x n binary matrix grid. You can move from a cell (row, col) to any of the cells (row + 1, col) or (row, col + 1) that has the value 1. The matrix is disconnected if there is no path from (0, 0) to (m - 1, n - 1).\nYou can flip the value of at most one (possibly none) cell. You cannot flip the cells (0, 0) and (m - 1, n - 1).\nReturn true if it is possible to make the matrix disconnect or false otherwise.\nNote that flipping a cell changes its value from 0 to 1 or from 1 to 0.\n \nExample 1:\n\nInput: grid = [[1,1,1],[1,0,0],[1,1,1]]\nOutput: true\nExplanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid.\n\nExample 2:\n\nInput: grid = [[1,1,1],[1,0,1],[1,1,1]]\nOutput: false\nExplanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2).\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 1000\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.\ngrid[0][0] == grid[m - 1][n - 1] == 1",
    "examples": [
      {
        "input": "Input: grid = [[1,1,1],[1,0,0],[1,1,1]]",
        "output": "Output: true",
        "explanation": "Explanation: We can change the cell shown in the diagram above. There is no path from (0, 0) to (2, 2) in the resulting grid."
      },
      {
        "input": "Input: grid = [[1,1,1],[1,0,1],[1,1,1]]",
        "output": "Output: false",
        "explanation": "Explanation: It is not possible to change at most one cell such that there is not path from (0, 0) to (2, 2)."
      }
    ],
    "topics": [
      "Array",
      "Dynamic Programming",
      "Depth-First Search",
      "Breadth-First Search",
      "Matrix"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Maximum Number of Integers to Choose From a Range I",
    "description": "You are given an integer array banned and two integers n and maxSum. You are choosing some number of integers following the below rules:\n\nThe chosen integers have to be in the range [1, n].\nEach integer can be chosen at most once.\nThe chosen integers should not be in the array banned.\nThe sum of the chosen integers should not exceed maxSum.\n\nReturn the maximum number of integers you can choose following the mentioned rules.\n \nExample 1:\nInput: banned = [1,6,5], n = 5, maxSum = 6\nOutput: 2\nExplanation: You can choose the integers 2 and 4.\n2 and 4 are from the range [1, 5], both did not appear in banned, and their sum is 6, which did not exceed maxSum.\n\nExample 2:\nInput: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1\nOutput: 0\nExplanation: You cannot choose any integer while following the mentioned conditions.\n\nExample 3:\nInput: banned = [11], n = 7, maxSum = 50\nOutput: 7\nExplanation: You can choose the integers 1, 2, 3, 4, 5, 6, and 7.\nThey are from the range [1, 7], all did not appear in banned, and their sum is 28, which did not exceed maxSum.\n\n \nConstraints:\n\n1 <= banned.length <= 104\n1 <= banned[i], n <= 104\n1 <= maxSum <= 109",
    "examples": [
      {
        "input": "Input: banned = [1,6,5], n = 5, maxSum = 6",
        "output": "Output: 2",
        "explanation": "Explanation: You can choose the integers 2 and 4."
      },
      {
        "input": "Input: banned = [1,2,3,4,5,6,7], n = 8, maxSum = 1",
        "output": "Output: 0",
        "explanation": "Explanation: You cannot choose any integer while following the mentioned conditions."
      },
      {
        "input": "Input: banned = [11], n = 7, maxSum = 50",
        "output": "Output: 7",
        "explanation": "Explanation: You can choose the integers 1, 2, 3, 4, 5, 6, and 7."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Binary Search",
      "Greedy",
      "Sorting"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Separate the Digits in an Array",
    "description": "Given an array of positive integers nums, return an array answer that consists of the digits of each integer in nums after separating them in the same order they appear in nums.\nTo separate the digits of an integer is to get all the digits it has in the same order.\n\nFor example, for the integer 10921, the separation of its digits is [1,0,9,2,1].\n\n \nExample 1:\nInput: nums = [13,25,83,77]\nOutput: [1,3,2,5,8,3,7,7]\nExplanation: \n- The separation of 13 is [1,3].\n- The separation of 25 is [2,5].\n- The separation of 83 is [8,3].\n- The separation of 77 is [7,7].\nanswer = [1,3,2,5,8,3,7,7]. Note that answer contains the separations in the same order.\n\nExample 2:\nInput: nums = [7,1,3,9]\nOutput: [7,1,3,9]\nExplanation: The separation of each integer in nums is itself.\nanswer = [7,1,3,9].\n\n \nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 105",
    "examples": [
      {
        "input": "Input: nums = [13,25,83,77]",
        "output": "Output: [1,3,2,5,8,3,7,7]",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: nums = [7,1,3,9]",
        "output": "Output: [7,1,3,9]",
        "explanation": "Explanation: The separation of each integer in nums is itself."
      }
    ],
    "topics": [
      "Array",
      "Simulation"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Maximum Subsequence Score",
    "description": "You are given two 0-indexed integer arrays nums1 and nums2 of equal length n and a positive integer k. You must choose a subsequence of indices from nums1 of length k.\nFor chosen indices i0, i1, ..., ik - 1, your score is defined as:\n\nThe sum of the selected elements from nums1 multiplied with the minimum of the selected elements from nums2.\nIt can defined simply as: (nums1[i0] + nums1[i1] +...+ nums1[ik - 1]) * min(nums2[i0] , nums2[i1], ... ,nums2[ik - 1]).\n\nReturn the maximum possible score.\nA subsequence of indices of an array is a set that can be derived from the set {0, 1, ..., n-1} by deleting some or no elements.\n \nExample 1:\nInput: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3\nOutput: 12\nExplanation: \nThe four possible subsequence scores are:\n- We choose the indices 0, 1, and 2 with score = (1+3+3) * min(2,1,3) = 7.\n- We choose the indices 0, 1, and 3 with score = (1+3+2) * min(2,1,4) = 6. \n- We choose the indices 0, 2, and 3 with score = (1+3+2) * min(2,3,4) = 12. \n- We choose the indices 1, 2, and 3 with score = (3+3+2) * min(1,3,4) = 8.\nTherefore, we return the max score, which is 12.\n\nExample 2:\nInput: nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1\nOutput: 30\nExplanation: \nChoosing index 2 is optimal: nums1[2] * nums2[2] = 3 * 10 = 30 is the maximum possible score.\n\n \nConstraints:\n\nn == nums1.length == nums2.length\n1 <= n <= 105\n0 <= nums1[i], nums2[j] <= 105\n1 <= k <= n",
    "examples": [
      {
        "input": "Input: nums1 = [1,3,3,2], nums2 = [2,1,3,4], k = 3",
        "output": "Output: 12",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: nums1 = [4,2,3,1,1], nums2 = [7,5,10,9,6], k = 1",
        "output": "Output: 30",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Greedy",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Check if Point Is Reachable",
    "description": "There exists an infinitely large grid. You are currently at point (1, 1), and you need to reach the point (targetX, targetY) using a finite number of steps.\nIn one step, you can move from point (x, y) to any one of the following points:\n\n(x, y - x)\n(x - y, y)\n(2 * x, y)\n(x, 2 * y)\n\nGiven two integers targetX and targetY representing the X-coordinate and Y-coordinate of your final position, return true if you can reach the point from (1, 1) using some number of steps, and false otherwise.\n \nExample 1:\nInput: targetX = 6, targetY = 9\nOutput: false\nExplanation: It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned.\n\nExample 2:\nInput: targetX = 4, targetY = 7\nOutput: true\nExplanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7).\n\n \nConstraints:\n\n1 <= targetX, targetY <= 109",
    "examples": [
      {
        "input": "Input: targetX = 6, targetY = 9",
        "output": "Output: false",
        "explanation": "Explanation: It is impossible to reach (6,9) from (1,1) using any sequence of moves, so false is returned."
      },
      {
        "input": "Input: targetX = 4, targetY = 7",
        "output": "Output: true",
        "explanation": "Explanation: You can follow the path (1,1) -> (1,2) -> (1,4) -> (1,8) -> (1,7) -> (2,7) -> (4,7)."
      }
    ],
    "topics": [
      "Math",
      "Number Theory"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Minimum Common Value",
    "description": "Given two integer arrays nums1 and nums2, sorted in non-decreasing order, return the minimum integer common to both arrays. If there is no common integer amongst nums1 and nums2, return -1.\nNote that an integer is said to be common to nums1 and nums2 if both arrays have at least one occurrence of that integer.\n \nExample 1:\nInput: nums1 = [1,2,3], nums2 = [2,4]\nOutput: 2\nExplanation: The smallest element common to both arrays is 2, so we return 2.\n\nExample 2:\nInput: nums1 = [1,2,3,6], nums2 = [2,3,4,5]\nOutput: 2\nExplanation: There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned.\n\n \nConstraints:\n\n1 <= nums1.length, nums2.length <= 105\n1 <= nums1[i], nums2[j] <= 109\nBoth nums1 and nums2 are sorted in non-decreasing order.",
    "examples": [
      {
        "input": "Input: nums1 = [1,2,3], nums2 = [2,4]",
        "output": "Output: 2",
        "explanation": "Explanation: The smallest element common to both arrays is 2, so we return 2."
      },
      {
        "input": "Input: nums1 = [1,2,3,6], nums2 = [2,3,4,5]",
        "output": "Output: 2",
        "explanation": "Explanation: There are two common elements in the array 2 and 3 out of which 2 is the smallest, so 2 is returned."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Two Pointers",
      "Binary Search"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Minimum Cost to Split an Array",
    "description": "You are given an integer array nums and an integer k.\nSplit the array into some number of non-empty subarrays. The cost of a split is the sum of the importance value of each subarray in the split.\nLet trimmed(subarray) be the version of the subarray where all numbers which appear only once are removed.\n\nFor example, trimmed([3,1,2,4,3,4]) = [3,4,3,4].\n\nThe importance value of a subarray is k + trimmed(subarray).length.\n\nFor example, if a subarray is [1,2,3,3,3,4,4], then trimmed([1,2,3,3,3,4,4]) = [3,3,3,4,4].The importance value of this subarray will be k + 5.\n\nReturn the minimum possible cost of a split of nums.\nA subarray is a contiguous non-empty sequence of elements within an array.\n \nExample 1:\nInput: nums = [1,2,1,2,1,3,3], k = 2\nOutput: 8\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1,3,3] is 2 + (2 + 2) = 6.\nThe cost of the split is 2 + 6 = 8. It can be shown that this is the minimum possible cost among all the possible splits.\n\nExample 2:\nInput: nums = [1,2,1,2,1], k = 2\nOutput: 6\nExplanation: We split nums to have two subarrays: [1,2], [1,2,1].\nThe importance value of [1,2] is 2 + (0) = 2.\nThe importance value of [1,2,1] is 2 + (2) = 4.\nThe cost of the split is 2 + 4 = 6. It can be shown that this is the minimum possible cost among all the possible splits.\n\nExample 3:\nInput: nums = [1,2,1,2,1], k = 5\nOutput: 10\nExplanation: We split nums to have one subarray: [1,2,1,2,1].\nThe importance value of [1,2,1,2,1] is 5 + (3 + 2) = 10.\nThe cost of the split is 10. It can be shown that this is the minimum possible cost among all the possible splits.\n\n \nConstraints:\n\n1 <= nums.length <= 1000\n0 <= nums[i] < nums.length\n1 <= k <= 109",
    "examples": [
      {
        "input": "Input: nums = [1,2,1,2,1,3,3], k = 2",
        "output": "Output: 8",
        "explanation": "Explanation: We split nums to have two subarrays: [1,2], [1,2,1,3,3]."
      },
      {
        "input": "Input: nums = [1,2,1,2,1], k = 2",
        "output": "Output: 6",
        "explanation": "Explanation: We split nums to have two subarrays: [1,2], [1,2,1]."
      },
      {
        "input": "Input: nums = [1,2,1,2,1], k = 5",
        "output": "Output: 10",
        "explanation": "Explanation: We split nums to have one subarray: [1,2,1,2,1]."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Dynamic Programming",
      "Counting"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Apply Bitwise Operations to Make Strings Equal",
    "description": "You are given two 0-indexed binary strings s and target of the same length n. You can do the following operation on s any number of times:\n\nChoose two different indices i and j where 0 <= i, j < n.\nSimultaneously, replace s[i] with (s[i] OR s[j]) and s[j] with (s[i] XOR s[j]).\n\nFor example, if s = \"0110\", you can choose i = 0 and j = 2, then simultaneously replace s[0] with (s[0] OR s[2] = 0 OR 1 = 1), and s[2] with (s[0] XOR s[2] = 0 XOR 1 = 1), so we will have s = \"1110\".\nReturn true if you can make the string s equal to target, or false otherwise.\n \nExample 1:\nInput: s = \"1010\", target = \"0110\"\nOutput: true\nExplanation: We can do the following operations:\n- Choose i = 2 and j = 0. We have now s = \"0010\".\n- Choose i = 2 and j = 1. We have now s = \"0110\".\nSince we can make s equal to target, we return true.\n\nExample 2:\nInput: s = \"11\", target = \"00\"\nOutput: false\nExplanation: It is not possible to make s equal to target with any number of operations.\n\n \nConstraints:\n\nn == s.length == target.length\n2 <= n <= 105\ns and target consist of only the digits 0 and 1.",
    "examples": [
      {
        "input": "Input: s = \"1010\", target = \"0110\"",
        "output": "Output: true",
        "explanation": "Explanation: We can do the following operations:"
      },
      {
        "input": "Input: s = \"11\", target = \"00\"",
        "output": "Output: false",
        "explanation": "Explanation: It is not possible to make s equal to target with any number of operations."
      }
    ],
    "topics": [
      "String",
      "Bit Manipulation"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Sort the Students by Their Kth Score",
    "description": "There is a class with m students and n exams. You are given a 0-indexed m x n integer matrix score, where each row represents one student and score[i][j] denotes the score the ith student got in the jth exam. The matrix score contains distinct integers only.\nYou are also given an integer k. Sort the students (i.e., the rows of the matrix) by their scores in the kth (0-indexed) exam from the highest to the lowest.\nReturn the matrix after sorting it.\n \nExample 1:\n\nInput: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2\nOutput: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]\nExplanation: In the above diagram, S denotes the student, while E denotes the exam.\n- The student with index 1 scored 11 in exam 2, which is the highest score, so they got first place.\n- The student with index 0 scored 9 in exam 2, which is the second highest score, so they got second place.\n- The student with index 2 scored 3 in exam 2, which is the lowest score, so they got third place.\n\nExample 2:\n\nInput: score = [[3,4],[5,6]], k = 0\nOutput: [[5,6],[3,4]]\nExplanation: In the above diagram, S denotes the student, while E denotes the exam.\n- The student with index 1 scored 5 in exam 0, which is the highest score, so they got first place.\n- The student with index 0 scored 3 in exam 0, which is the lowest score, so they got second place.\n\n \nConstraints:\n\nm == score.length\nn == score[i].length\n1 <= m, n <= 250\n1 <= score[i][j] <= 105\nscore consists of distinct integers.\n0 <= k < n",
    "examples": [
      {
        "input": "Input: score = [[10,6,9,1],[7,5,11,2],[4,8,3,15]], k = 2",
        "output": "Output: [[7,5,11,2],[10,6,9,1],[4,8,3,15]]",
        "explanation": "Explanation: In the above diagram, S denotes the student, while E denotes the exam."
      },
      {
        "input": "Input: score = [[3,4],[5,6]], k = 0",
        "output": "Output: [[5,6],[3,4]]",
        "explanation": "Explanation: In the above diagram, S denotes the student, while E denotes the exam."
      }
    ],
    "topics": [
      "Array",
      "Sorting",
      "Matrix"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Alternating Digit Sum",
    "description": "You are given a positive integer n. Each digit of n has a sign according to the following rules:\n\nThe most significant digit is assigned a positive sign.\nEach other digit has an opposite sign to its adjacent digits.\n\nReturn the sum of all digits with their corresponding sign.\n \nExample 1:\nInput: n = 521\nOutput: 4\nExplanation: (+5) + (-2) + (+1) = 4.\n\nExample 2:\nInput: n = 111\nOutput: 1\nExplanation: (+1) + (-1) + (+1) = 1.\n\nExample 3:\nInput: n = 886996\nOutput: 0\nExplanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0.\n\n \nConstraints:\n\n1 <= n <= 109",
    "examples": [
      {
        "input": "Input: n = 521",
        "output": "Output: 4",
        "explanation": "Explanation: (+5) + (-2) + (+1) = 4."
      },
      {
        "input": "Input: n = 111",
        "output": "Output: 1",
        "explanation": "Explanation: (+1) + (-1) + (+1) = 1."
      },
      {
        "input": "Input: n = 886996",
        "output": "Output: 0",
        "explanation": "Explanation: (+8) + (-8) + (+6) + (-9) + (+9) + (-6) = 0."
      }
    ],
    "topics": [
      "Math"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Minimize the Maximum of Two Arrays",
    "description": "We have two arrays arr1 and arr2 which are initially empty. You need to add positive integers to them such that they satisfy all the following conditions:\n\narr1 contains uniqueCnt1 distinct positive integers, each of which is not divisible by divisor1.\narr2 contains uniqueCnt2 distinct positive integers, each of which is not divisible by divisor2.\nNo integer is present in both arr1 and arr2.\n\nGiven divisor1, divisor2, uniqueCnt1, and uniqueCnt2, return the minimum possible maximum integer that can be present in either array.\n \nExample 1:\nInput: divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3\nOutput: 4\nExplanation: \nWe can distribute the first 4 natural numbers into arr1 and arr2.\narr1 = [1] and arr2 = [2,3,4].\nWe can see that both arrays satisfy all the conditions.\nSince the maximum value is 4, we return it.\n\nExample 2:\nInput: divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1\nOutput: 3\nExplanation: \nHere arr1 = [1,2], and arr2 = [3] satisfy all conditions.\nSince the maximum value is 3, we return it.\nExample 3:\nInput: divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2\nOutput: 15\nExplanation: \nHere, the final possible arrays can be arr1 = [1,3,5,7,9,11,13,15], and arr2 = [2,6].\nIt can be shown that it is not possible to obtain a lower maximum satisfying all conditions. \n\n \nConstraints:\n\n2 <= divisor1, divisor2 <= 105\n1 <= uniqueCnt1, uniqueCnt2 < 109\n2 <= uniqueCnt1 + uniqueCnt2 <= 109",
    "examples": [
      {
        "input": "Input: divisor1 = 2, divisor2 = 7, uniqueCnt1 = 1, uniqueCnt2 = 3",
        "output": "Output: 4",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: divisor1 = 3, divisor2 = 5, uniqueCnt1 = 2, uniqueCnt2 = 1",
        "output": "Output: 3",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: divisor1 = 2, divisor2 = 4, uniqueCnt1 = 8, uniqueCnt2 = 2",
        "output": "Output: 15",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Math",
      "Binary Search",
      "Number Theory"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Difference Between Maximum and Minimum Price Sum",
    "description": "There exists an undirected and initially unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nThe tree can be rooted at any node root of your choice. The incurred cost after choosing root is the difference between the maximum and minimum price sum amongst all paths starting at root.\nReturn the maximum possible cost amongst all possible root choices.\n \nExample 1:\n\nInput: n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]\nOutput: 24\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes [2,1,3,4]: the prices are [7,8,6,10], and the sum of the prices is 31.\n- The second path contains the node [2] with the price [7].\nThe difference between the maximum and minimum price sum is 24. It can be proved that 24 is the maximum cost.\n\nExample 2:\n\nInput: n = 3, edges = [[0,1],[1,2]], price = [1,1,1]\nOutput: 2\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum.\n- The first path contains nodes [0,1,2]: the prices are [1,1,1], and the sum of the prices is 3.\n- The second path contains node [0] with a price [1].\nThe difference between the maximum and minimum price sum is 2. It can be proved that 2 is the maximum cost.\n\n \nConstraints:\n\n1 <= n <= 105\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\n1 <= price[i] <= 105",
    "examples": [
      {
        "input": "Input: n = 6, edges = [[0,1],[1,2],[1,3],[3,4],[3,5]], price = [9,8,7,6,10,5]",
        "output": "Output: 24",
        "explanation": "Explanation: The diagram above denotes the tree after rooting it at node 2. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum."
      },
      {
        "input": "Input: n = 3, edges = [[0,1],[1,2]], price = [1,1,1]",
        "output": "Output: 2",
        "explanation": "Explanation: The diagram above denotes the tree after rooting it at node 0. The first part (colored in red) shows the path with the maximum price sum. The second part (colored in blue) shows the path with the minimum price sum."
      }
    ],
    "topics": [
      "Array",
      "Dynamic Programming",
      "Tree",
      "Depth-First Search"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Count the Number of Good Subarrays",
    "description": "Given an integer array nums and an integer k, return the number of good subarrays of nums.\nA subarray arr is good if it there are at least k pairs of indices (i, j) such that i < j and arr[i] == arr[j].\nA subarray is a contiguous non-empty sequence of elements within an array.\n \nExample 1:\nInput: nums = [1,1,1,1,1], k = 10\nOutput: 1\nExplanation: The only good subarray is the array nums itself.\n\nExample 2:\nInput: nums = [3,1,4,3,2,2,4], k = 2\nOutput: 4\nExplanation: There are 4 different good subarrays:\n- [3,1,4,3,2,2] that has 2 pairs.\n- [3,1,4,3,2,2,4] that has 3 pairs.\n- [1,4,3,2,2,4] that has 2 pairs.\n- [4,3,2,2,4] that has 2 pairs.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i], k <= 109",
    "examples": [
      {
        "input": "Input: nums = [1,1,1,1,1], k = 10",
        "output": "Output: 1",
        "explanation": "Explanation: The only good subarray is the array nums itself."
      },
      {
        "input": "Input: nums = [3,1,4,3,2,2,4], k = 2",
        "output": "Output: 4",
        "explanation": "Explanation: There are 4 different good subarrays:"
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Sliding Window"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Increment Submatrices by One",
    "description": "You are given a positive integer n, indicating that we initially have an n x n 0-indexed integer matrix mat filled with zeroes.\nYou are also given a 2D integer array query. For each query[i] = [row1i, col1i, row2i, col2i], you should do the following operation:\n\nAdd 1 to every element in the submatrix with the top left corner (row1i, col1i) and the bottom right corner (row2i, col2i). That is, add 1 to mat[x][y] for all row1i <= x <= row2i and col1i <= y <= col2i.\n\nReturn the matrix mat after performing every query.\n \nExample 1:\n\nInput: n = 3, queries = [[1,1,2,2],[0,0,1,1]]\nOutput: [[1,1,0],[1,2,1],[0,1,1]]\nExplanation: The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query.\n- In the first query, we add 1 to every element in the submatrix with the top left corner (1, 1) and bottom right corner (2, 2).\n- In the second query, we add 1 to every element in the submatrix with the top left corner (0, 0) and bottom right corner (1, 1).\n\nExample 2:\n\nInput: n = 2, queries = [[0,0,1,1]]\nOutput: [[1,1],[1,1]]\nExplanation: The diagram above shows the initial matrix and the matrix after the first query.\n- In the first query we add 1 to every element in the matrix.\n\n \nConstraints:\n\n1 <= n <= 500\n1 <= queries.length <= 104\n0 <= row1i <= row2i < n\n0 <= col1i <= col2i < n",
    "examples": [
      {
        "input": "Input: n = 3, queries = [[1,1,2,2],[0,0,1,1]]",
        "output": "Output: [[1,1,0],[1,2,1],[0,1,1]]",
        "explanation": "Explanation: The diagram above shows the initial matrix, the matrix after the first query, and the matrix after the second query."
      },
      {
        "input": "Input: n = 2, queries = [[0,0,1,1]]",
        "output": "Output: [[1,1],[1,1]]",
        "explanation": "Explanation: The diagram above shows the initial matrix and the matrix after the first query."
      }
    ],
    "topics": [
      "Array",
      "Matrix",
      "Prefix Sum"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Difference Between Element Sum and Digit Sum of an Array",
    "description": "You are given a positive integer array nums.\n\nThe element sum is the sum of all the elements in nums.\nThe digit sum is the sum of all the digits (not necessarily distinct) that appear in nums.\n\nReturn the absolute difference between the element sum and digit sum of nums.\nNote that the absolute difference between two integers x and y is defined as |x - y|.\n \nExample 1:\nInput: nums = [1,15,6,3]\nOutput: 9\nExplanation: \nThe element sum of nums is 1 + 15 + 6 + 3 = 25.\nThe digit sum of nums is 1 + 1 + 5 + 6 + 3 = 16.\nThe absolute difference between the element sum and digit sum is |25 - 16| = 9.\n\nExample 2:\nInput: nums = [1,2,3,4]\nOutput: 0\nExplanation:\nThe element sum of nums is 1 + 2 + 3 + 4 = 10.\nThe digit sum of nums is 1 + 2 + 3 + 4 = 10.\nThe absolute difference between the element sum and digit sum is |10 - 10| = 0.\n\n \nConstraints:\n\n1 <= nums.length <= 2000\n1 <= nums[i] <= 2000",
    "examples": [
      {
        "input": "Input: nums = [1,15,6,3]",
        "output": "Output: 9",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: nums = [1,2,3,4]",
        "output": "Output: 0",
        "explanation": ""
      }
    ],
    "topics": [
      "Array",
      "Math"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Find Xor-Beauty of Array",
    "description": "You are given a 0-indexed integer array nums.\nThe effective value of three indices i, j, and k is defined as ((nums[i] | nums[j]) & nums[k]).\nThe xor-beauty of the array is the XORing of the effective values of all the possible triplets of indices (i, j, k) where 0 <= i, j, k < n.\nReturn the xor-beauty of nums.\nNote that:\n\nval1 | val2 is bitwise OR of val1 and val2.\nval1 & val2 is bitwise AND of val1 and val2.\n\n \nExample 1:\nInput: nums = [1,4]\nOutput: 5\nExplanation: \nThe triplets and their corresponding effective values are listed below:\n- (0,0,0) with effective value ((1 | 1) & 1) = 1\n- (0,0,1) with effective value ((1 | 1) & 4) = 0\n- (0,1,0) with effective value ((1 | 4) & 1) = 1\n- (0,1,1) with effective value ((1 | 4) & 4) = 4\n- (1,0,0) with effective value ((4 | 1) & 1) = 1\n- (1,0,1) with effective value ((4 | 1) & 4) = 4\n- (1,1,0) with effective value ((4 | 4) & 1) = 0\n- (1,1,1) with effective value ((4 | 4) & 4) = 4 \nXor-beauty of array will be bitwise XOR of all beauties = 1 ^ 0 ^ 1 ^ 4 ^ 1 ^ 4 ^ 0 ^ 4 = 5.\nExample 2:\nInput: nums = [15,45,20,2,34,35,5,44,32,30]\nOutput: 34\nExplanation: The xor-beauty of the given array is 34.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109",
    "examples": [
      {
        "input": "Input: nums = [1,4]",
        "output": "Output: 5",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: nums = [15,45,20,2,34,35,5,44,32,30]",
        "output": "Output: 34",
        "explanation": "Explanation: The xor-beauty of the given array is 34."
      }
    ],
    "topics": [
      "Array",
      "Math",
      "Bit Manipulation"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Find Consecutive Integers from a Data Stream",
    "description": "For a stream of integers, implement a data structure that checks if the last k integers parsed in the stream are equal to value.\nImplement the DataStream class:\n\nDataStream(int value, int k) Initializes the object with an empty integer stream and the two integers value and k.\nboolean consec(int num) Adds num to the stream of integers. Returns true if the last k integers are equal to value, and false otherwise. If there are less than k integers, the condition does not hold true, so returns false.\n\n \nExample 1:\nInput\n[\"DataStream\", \"consec\", \"consec\", \"consec\", \"consec\"]\n[[4, 3], [4], [4], [4], [3]]\nOutput\n[null, false, false, true, false]\n\nExplanation\nDataStream dataStream = new DataStream(4, 3); //value = 4, k = 3 \ndataStream.consec(4); // Only 1 integer is parsed, so returns False. \ndataStream.consec(4); // Only 2 integers are parsed.\n                      // Since 2 is less than k, returns False. \ndataStream.consec(4); // The 3 integers parsed are all equal to value, so returns True. \ndataStream.consec(3); // The last k integers parsed in the stream are [4,4,3].\n                      // Since 3 is not equal to value, it returns False.\n\n \nConstraints:\n\n1 <= value, num <= 109\n1 <= k <= 105\nAt most 105 calls will be made to consec.",
    "examples": [
      {
        "input": "Input\n[\"DataStream\", \"consec\", \"consec\", \"consec\", \"consec\"]",
        "output": "Output\n[null, false, false, true, false]",
        "explanation": "Explanation\nDataStream dataStream = new DataStream(4, 3); //value = 4, k = 3 "
      }
    ],
    "topics": [
      "Hash Table",
      "Design",
      "Queue",
      "Counting",
      "Data Stream"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Categorize Box According to Criteria",
    "description": "Given four integers length, width, height, and mass, representing the dimensions and mass of a box, respectively, return a string representing the category of the box.\n\nThe box is \"Bulky\" if:\n\n\t\nAny of the dimensions of the box is greater or equal to 104.\nOr, the volume of the box is greater or equal to 109.\n\n\nIf the mass of the box is greater or equal to 100, it is \"Heavy\".\nIf the box is both \"Bulky\" and \"Heavy\", then its category is \"Both\".\nIf the box is neither \"Bulky\" nor \"Heavy\", then its category is \"Neither\".\nIf the box is \"Bulky\" but not \"Heavy\", then its category is \"Bulky\".\nIf the box is \"Heavy\" but not \"Bulky\", then its category is \"Heavy\".\n\nNote that the volume of the box is the product of its length, width and height.\n \nExample 1:\nInput: length = 1000, width = 35, height = 700, mass = 300\nOutput: \"Heavy\"\nExplanation: \nNone of the dimensions of the box is greater or equal to 104. \nIts volume = 24500000 <= 109. So it cannot be categorized as \"Bulky\".\nHowever mass >= 100, so the box is \"Heavy\".\nSince the box is not \"Bulky\" but \"Heavy\", we return \"Heavy\".\nExample 2:\nInput: length = 200, width = 50, height = 800, mass = 50\nOutput: \"Neither\"\nExplanation: \nNone of the dimensions of the box is greater or equal to 104.\nIts volume = 8 * 106 <= 109. So it cannot be categorized as \"Bulky\".\nIts mass is also less than 100, so it cannot be categorized as \"Heavy\" either. \nSince its neither of the two above categories, we return \"Neither\".\n \nConstraints:\n\n1 <= length, width, height <= 105\n1 <= mass <= 103",
    "examples": [
      {
        "input": "Input: length = 1000, width = 35, height = 700, mass = 300",
        "output": "Output: \"Heavy\"",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: length = 200, width = 50, height = 800, mass = 50",
        "output": "Output: \"Neither\"",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Math"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Maximize the Minimum Powered City",
    "description": "You are given a 0-indexed integer array stations of length n, where stations[i] represents the number of power stations in the ith city.\nEach power station can provide power to every city in a fixed range. In other words, if the range is denoted by r, then a power station at city i can provide power to all cities j such that |i - j| <= r and 0 <= i, j <= n - 1.\n\nNote that |x| denotes absolute value. For example, |7 - 5| = 2 and |3 - 10| = 7.\n\nThe power of a city is the total number of power stations it is being provided power from.\nThe government has sanctioned building k more power stations, each of which can be built in any city, and have the same range as the pre-existing ones.\nGiven the two integers r and k, return the maximum possible minimum power of a city, if the additional power stations are built optimally.\nNote that you can build the k power stations in multiple cities.\n \nExample 1:\nInput: stations = [1,2,4,5,0], r = 1, k = 2\nOutput: 5\nExplanation: \nOne of the optimal ways is to install both the power stations at city 1. \nSo stations will become [1,4,4,5,0].\n- City 0 is provided by 1 + 4 = 5 power stations.\n- City 1 is provided by 1 + 4 + 4 = 9 power stations.\n- City 2 is provided by 4 + 4 + 5 = 13 power stations.\n- City 3 is provided by 5 + 4 = 9 power stations.\n- City 4 is provided by 5 + 0 = 5 power stations.\nSo the minimum power of a city is 5.\nSince it is not possible to obtain a larger power, we return 5.\n\nExample 2:\nInput: stations = [4,4,4,4], r = 0, k = 3\nOutput: 4\nExplanation: \nIt can be proved that we cannot make the minimum power of a city greater than 4.\n\n \nConstraints:\n\nn == stations.length\n1 <= n <= 105\n0 <= stations[i] <= 105\n0 <= r <= n - 1\n0 <= k <= 109",
    "examples": [
      {
        "input": "Input: stations = [1,2,4,5,0], r = 1, k = 2",
        "output": "Output: 5",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: stations = [4,4,4,4], r = 0, k = 3",
        "output": "Output: 4",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Binary Search",
      "Greedy",
      "Queue",
      "Sliding Window",
      "Prefix Sum"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Maximal Score After Applying K Operations",
    "description": "You are given a 0-indexed integer array nums and an integer k. You have a starting score of 0.\nIn one operation:\n\nchoose an index i such that 0 <= i < nums.length,\nincrease your score by nums[i], and\nreplace nums[i] with ceil(nums[i] / 3).\n\nReturn the maximum possible score you can attain after applying exactly k operations.\nThe ceiling function ceil(val) is the least integer greater than or equal to val.\n \nExample 1:\nInput: nums = [10,10,10,10,10], k = 5\nOutput: 50\nExplanation: Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50.\n\nExample 2:\nInput: nums = [1,10,3,3,3], k = 3\nOutput: 17\nExplanation: You can do the following operations:\nOperation 1: Select i = 1, so nums becomes [1,4,3,3,3]. Your score increases by 10.\nOperation 2: Select i = 1, so nums becomes [1,2,3,3,3]. Your score increases by 4.\nOperation 3: Select i = 2, so nums becomes [1,1,1,3,3]. Your score increases by 3.\nThe final score is 10 + 4 + 3 = 17.\n\n \nConstraints:\n\n1 <= nums.length, k <= 105\n1 <= nums[i] <= 109",
    "examples": [
      {
        "input": "Input: nums = [10,10,10,10,10], k = 5",
        "output": "Output: 50",
        "explanation": "Explanation: Apply the operation to each array element exactly once. The final score is 10 + 10 + 10 + 10 + 10 = 50."
      },
      {
        "input": "Input: nums = [1,10,3,3,3], k = 3",
        "output": "Output: 17",
        "explanation": "Explanation: You can do the following operations:"
      }
    ],
    "topics": [
      "Array",
      "Greedy",
      "Heap (Priority Queue)"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Make Number of Distinct Characters Equal",
    "description": "You are given two 0-indexed strings word1 and word2.\nA move consists of choosing two indices i and j such that 0 <= i < word1.length and 0 <= j < word2.length and swapping word1[i] with word2[j].\nReturn true if it is possible to get the number of distinct characters in word1 and word2 to be equal with exactly one move. Return false otherwise.\n \nExample 1:\nInput: word1 = \"ac\", word2 = \"b\"\nOutput: false\nExplanation: Any pair of swaps would yield two distinct characters in the first string, and one in the second string.\n\nExample 2:\nInput: word1 = \"abcc\", word2 = \"aab\"\nOutput: true\nExplanation: We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = \"abac\" and word2 = \"cab\", which both have 3 distinct characters.\n\nExample 3:\nInput: word1 = \"abcde\", word2 = \"fghij\"\nOutput: true\nExplanation: Both resulting strings will have 5 distinct characters, regardless of which indices we swap.\n\n \nConstraints:\n\n1 <= word1.length, word2.length <= 105\nword1 and word2 consist of only lowercase English letters.",
    "examples": [
      {
        "input": "Input: word1 = \"ac\", word2 = \"b\"",
        "output": "Output: false",
        "explanation": "Explanation: Any pair of swaps would yield two distinct characters in the first string, and one in the second string."
      },
      {
        "input": "Input: word1 = \"abcc\", word2 = \"aab\"",
        "output": "Output: true",
        "explanation": "Explanation: We swap index 2 of the first string with index 0 of the second string. The resulting strings are word1 = \"abac\" and word2 = \"cab\", which both have 3 distinct characters."
      },
      {
        "input": "Input: word1 = \"abcde\", word2 = \"fghij\"",
        "output": "Output: true",
        "explanation": "Explanation: Both resulting strings will have 5 distinct characters, regardless of which indices we swap."
      }
    ],
    "topics": [
      "Hash Table",
      "String",
      "Counting"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Maximum Count of Positive Integer and Negative Integer",
    "description": "Given an array nums sorted in non-decreasing order, return the maximum between the number of positive integers and the number of negative integers.\n\nIn other words, if the number of positive integers in nums is pos and the number of negative integers is neg, then return the maximum of pos and neg.\n\nNote that 0 is neither positive nor negative.\n \nExample 1:\nInput: nums = [-2,-1,-1,1,2,3]\nOutput: 3\nExplanation: There are 3 positive integers and 3 negative integers. The maximum count among them is 3.\n\nExample 2:\nInput: nums = [-3,-2,-1,0,0,1,2]\nOutput: 3\nExplanation: There are 2 positive integers and 3 negative integers. The maximum count among them is 3.\n\nExample 3:\nInput: nums = [5,20,66,1314]\nOutput: 4\nExplanation: There are 4 positive integers and 0 negative integers. The maximum count among them is 4.\n\n \nConstraints:\n\n1 <= nums.length <= 2000\n-2000 <= nums[i] <= 2000\nnums is sorted in a non-decreasing order.\n\n \nFollow up: Can you solve the problem in O(log(n)) time complexity?",
    "examples": [
      {
        "input": "Input: nums = [-2,-1,-1,1,2,3]",
        "output": "Output: 3",
        "explanation": "Explanation: There are 3 positive integers and 3 negative integers. The maximum count among them is 3."
      },
      {
        "input": "Input: nums = [-3,-2,-1,0,0,1,2]",
        "output": "Output: 3",
        "explanation": "Explanation: There are 2 positive integers and 3 negative integers. The maximum count among them is 3."
      },
      {
        "input": "Input: nums = [5,20,66,1314]",
        "output": "Output: 4",
        "explanation": "Explanation: There are 4 positive integers and 0 negative integers. The maximum count among them is 4."
      }
    ],
    "topics": [
      "Array",
      "Binary Search",
      "Counting"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Closest Prime Numbers in Range",
    "description": "Given two positive integers left and right, find the two integers num1 and num2 such that:\n\nleft <= nums1 < nums2 <= right .\nnums1 and nums2 are both prime numbers.\nnums2 - nums1 is the minimum amongst all other pairs satisfying the above conditions.\n\nReturn the positive integer array ans = [nums1, nums2]. If there are multiple pairs satisfying these conditions, return the one with the minimum nums1 value or [-1, -1] if such numbers do not exist.\nA number greater than 1 is called prime if it is only divisible by 1 and itself.\n \nExample 1:\nInput: left = 10, right = 19\nOutput: [11,13]\nExplanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19.\nThe closest gap between any pair is 2, which can be achieved by [11,13] or [17,19].\nSince 11 is smaller than 17, we return the first pair.\n\nExample 2:\nInput: left = 4, right = 6\nOutput: [-1,-1]\nExplanation: There exists only one prime number in the given range, so the conditions cannot be satisfied.\n\n \nConstraints:\n\n1 <= left <= right <= 106",
    "examples": [
      {
        "input": "Input: left = 10, right = 19",
        "output": "Output: [11,13]",
        "explanation": "Explanation: The prime numbers between 10 and 19 are 11, 13, 17, and 19."
      },
      {
        "input": "Input: left = 4, right = 6",
        "output": "Output: [-1,-1]",
        "explanation": "Explanation: There exists only one prime number in the given range, so the conditions cannot be satisfied."
      }
    ],
    "topics": [
      "Math",
      "Number Theory"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Distinct Prime Factors of Product of Array",
    "description": "Given an array of positive integers nums, return the number of distinct prime factors in the product of the elements of nums.\nNote that:\n\nA number greater than 1 is called prime if it is divisible by only 1 and itself.\nAn integer val1 is a factor of another integer val2 if val2 / val1 is an integer.\n\n \nExample 1:\nInput: nums = [2,4,3,7,10,6]\nOutput: 4\nExplanation:\nThe product of all the elements in nums is: 2 * 4 * 3 * 7 * 10 * 6 = 10080 = 25 * 32 * 5 * 7.\nThere are 4 distinct prime factors so we return 4.\n\nExample 2:\nInput: nums = [2,4,8,16]\nOutput: 1\nExplanation:\nThe product of all the elements in nums is: 2 * 4 * 8 * 16 = 1024 = 210.\nThere is 1 distinct prime factor so we return 1.\n\n \nConstraints:\n\n1 <= nums.length <= 104\n2 <= nums[i] <= 1000",
    "examples": [
      {
        "input": "Input: nums = [2,4,3,7,10,6]",
        "output": "Output: 4",
        "explanation": ""
      },
      {
        "input": "Input: nums = [2,4,8,16]",
        "output": "Output: 1",
        "explanation": ""
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Math",
      "Number Theory"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Count the Digits That Divide a Number",
    "description": "Given an integer num, return the number of digits in num that divide num.\nAn integer val divides nums if nums % val == 0.\n \nExample 1:\nInput: num = 7\nOutput: 1\nExplanation: 7 divides itself, hence the answer is 1.\n\nExample 2:\nInput: num = 121\nOutput: 2\nExplanation: 121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2.\n\nExample 3:\nInput: num = 1248\nOutput: 4\nExplanation: 1248 is divisible by all of its digits, hence the answer is 4.\n\n \nConstraints:\n\n1 <= num <= 109\nnum does not contain 0 as one of its digits.",
    "examples": [
      {
        "input": "Input: num = 7",
        "output": "Output: 1",
        "explanation": "Explanation: 7 divides itself, hence the answer is 1."
      },
      {
        "input": "Input: num = 121",
        "output": "Output: 2",
        "explanation": "Explanation: 121 is divisible by 1, but not 2. Since 1 occurs twice as a digit, we return 2."
      },
      {
        "input": "Input: num = 1248",
        "output": "Output: 4",
        "explanation": "Explanation: 1248 is divisible by all of its digits, hence the answer is 4."
      }
    ],
    "topics": [
      "Math"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Difference Between Ones and Zeros in Row and Column",
    "description": "You are given a 0-indexed m x n binary matrix grid.\nA 0-indexed m x n difference matrix diff is created with the following procedure:\n\nLet the number of ones in the ith row be onesRowi.\nLet the number of ones in the jth column be onesColj.\nLet the number of zeros in the ith row be zerosRowi.\nLet the number of zeros in the jth column be zerosColj.\ndiff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj\n\nReturn the difference matrix diff.\n \nExample 1:\n\nInput: grid = [[0,1,1],[1,0,1],[0,0,1]]\nOutput: [[0,0,4],[0,0,4],[-2,-2,2]]\nExplanation:\n- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 \n- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 \n- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 \n- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 \n- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 \n- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 \n- diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2\n- diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2\n- diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2\n\nExample 2:\n\nInput: grid = [[1,1,1],[1,1,1]]\nOutput: [[5,5,5],[5,5,5]]\nExplanation:\n- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5\n- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 105\n1 <= m * n <= 105\ngrid[i][j] is either 0 or 1.",
    "examples": [
      {
        "input": "Input: grid = [[0,1,1],[1,0,1],[0,0,1]]",
        "output": "Output: [[0,0,4],[0,0,4],[-2,-2,2]]",
        "explanation": ""
      },
      {
        "input": "Input: grid = [[1,1,1],[1,1,1]]",
        "output": "Output: [[5,5,5],[5,5,5]]",
        "explanation": ""
      }
    ],
    "topics": [
      "Array",
      "Matrix",
      "Simulation"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Count Anagrams",
    "description": "You are given a string s containing one or more words. Every consecutive pair of words is separated by a single space ' '.\nA string t is an anagram of string s if the ith word of t is a permutation of the ith word of s.\n\nFor example, \"acb dfe\" is an anagram of \"abc def\", but \"def cab\" and \"adc bef\" are not.\n\nReturn the number of distinct anagrams of s. Since the answer may be very large, return it modulo 109 + 7.\n \nExample 1:\nInput: s = \"too hot\"\nOutput: 18\nExplanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\".\n\nExample 2:\nInput: s = \"aa\"\nOutput: 1\nExplanation: There is only one anagram possible for the given string.\n \nConstraints:\n\n1 <= s.length <= 105\ns consists of lowercase English letters and spaces ' '.\nThere is single space between consecutive words.",
    "examples": [
      {
        "input": "Input: s = \"too hot\"",
        "output": "Output: 18",
        "explanation": "Explanation: Some of the anagrams of the given string are \"too hot\", \"oot hot\", \"oto toh\", \"too toh\", and \"too oht\"."
      },
      {
        "input": "Input: s = \"aa\"",
        "output": "Output: 1",
        "explanation": "Explanation: There is only one anagram possible for the given string."
      }
    ],
    "topics": [
      "Hash Table",
      "Math",
      "String",
      "Combinatorics",
      "Counting"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Minimum Operations to Make Array Equal II",
    "description": "You are given two integer arrays nums1 and nums2 of equal length n and an integer k. You can perform the following operation on nums1:\n\nChoose two indexes i and j and increment nums1[i] by k and decrement nums1[j] by k. In other words, nums1[i] = nums1[i] + k and nums1[j] = nums1[j] - k.\n\nnums1 is said to be equal to nums2 if for all indices i such that 0 <= i < n, nums1[i] == nums2[i].\nReturn the minimum number of operations required to make nums1 equal to nums2. If it is impossible to make them equal, return -1.\n \nExample 1:\nInput: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3\nOutput: 2\nExplanation: In 2 operations, we can transform nums1 to nums2.\n1st operation: i = 2, j = 0. After applying the operation, nums1 = [1,3,4,4].\n2nd operation: i = 2, j = 3. After applying the operation, nums1 = [1,3,7,1].\nOne can prove that it is impossible to make arrays equal in fewer operations.\nExample 2:\nInput: nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1\nOutput: -1\nExplanation: It can be proved that it is impossible to make the two arrays equal.\n\n \nConstraints:\n\nn == nums1.length == nums2.length\n2 <= n <= 105\n0 <= nums1[i], nums2[j] <= 109\n0 <= k <= 105",
    "examples": [
      {
        "input": "Input: nums1 = [4,3,1,4], nums2 = [1,3,7,1], k = 3",
        "output": "Output: 2",
        "explanation": "Explanation: In 2 operations, we can transform nums1 to nums2."
      },
      {
        "input": "Input: nums1 = [3,8,5,2], nums2 = [2,4,1,6], k = 1",
        "output": "Output: -1",
        "explanation": "Explanation: It can be proved that it is impossible to make the two arrays equal."
      }
    ],
    "topics": [
      "Array",
      "Math",
      "Greedy"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Reward Top K Students",
    "description": "You are given two string arrays positive_feedback and negative_feedback, containing the words denoting positive and negative feedback, respectively. Note that no word is both positive and negative.\nInitially every student has 0 points. Each positive word in a feedback report increases the points of a student by 3, whereas each negative word decreases the points by 1.\nYou are given n feedback reports, represented by a 0-indexed string array report and a 0-indexed integer array student_id, where student_id[i] represents the ID of the student who has received the feedback report report[i]. The ID of each student is unique.\nGiven an integer k, return the top k students after ranking them in non-increasing order by their points. In case more than one student has the same points, the one with the lower ID ranks higher.\n \nExample 1:\nInput: positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is studious\",\"the student is smart\"], student_id = [1,2], k = 2\nOutput: [1,2]\nExplanation: \nBoth the students have 1 positive feedback and 3 points but since student 1 has a lower ID he ranks higher.\n\nExample 2:\nInput: positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is not studious\",\"the student is smart\"], student_id = [1,2], k = 2\nOutput: [2,1]\nExplanation: \n- The student with ID 1 has 1 positive feedback and 1 negative feedback, so he has 3-1=2 points. \n- The student with ID 2 has 1 positive feedback, so he has 3 points. \nSince student 2 has more points, [2,1] is returned.\n\n \nConstraints:\n\n1 <= positive_feedback.length, negative_feedback.length <= 104\n1 <= positive_feedback[i].length, negative_feedback[j].length <= 100\nBoth positive_feedback[i] and negative_feedback[j] consists of lowercase English letters.\nNo word is present in both positive_feedback and negative_feedback.\nn == report.length == student_id.length\n1 <= n <= 104\nreport[i] consists of lowercase English letters and spaces ' '.\nThere is a single space between consecutive words of report[i].\n1 <= report[i].length <= 100\n1 <= student_id[i] <= 109\nAll the values of student_id[i] are unique.\n1 <= k <= n",
    "examples": [
      {
        "input": "Input: positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is studious\",\"the student is smart\"], student_id = [1,2], k = 2",
        "output": "Output: [1,2]",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: positive_feedback = [\"smart\",\"brilliant\",\"studious\"], negative_feedback = [\"not\"], report = [\"this student is not studious\",\"the student is smart\"], student_id = [1,2], k = 2",
        "output": "Output: [2,1]",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "String",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Maximum Enemy Forts That Can Be Captured",
    "description": "You are given a 0-indexed integer array forts of length n representing the positions of several forts. forts[i] can be -1, 0, or 1 where:\n\n-1 represents there is no fort at the ith position.\n0 indicates there is an enemy fort at the ith position.\n1 indicates the fort at the ith the position is under your command.\n\nNow you have decided to move your army from one of your forts at position i to an empty position j such that:\n\n0 <= i, j <= n - 1\nThe army travels over enemy forts only. Formally, for all k where min(i,j) < k < max(i,j), forts[k] == 0.\n\nWhile moving the army, all the enemy forts that come in the way are captured.\nReturn the maximum number of enemy forts that can be captured. In case it is impossible to move your army, or you do not have any fort under your command, return 0.\n \nExample 1:\nInput: forts = [1,0,0,-1,0,0,0,0,1]\nOutput: 4\nExplanation:\n- Moving the army from position 0 to position 3 captures 2 enemy forts, at 1 and 2.\n- Moving the army from position 8 to position 3 captures 4 enemy forts.\nSince 4 is the maximum number of enemy forts that can be captured, we return 4.\n\nExample 2:\nInput: forts = [0,0,1,-1]\nOutput: 0\nExplanation: Since no enemy fort can be captured, 0 is returned.\n\n \nConstraints:\n\n1 <= forts.length <= 1000\n-1 <= forts[i] <= 1",
    "examples": [
      {
        "input": "Input: forts = [1,0,0,-1,0,0,0,0,1]",
        "output": "Output: 4",
        "explanation": ""
      },
      {
        "input": "Input: forts = [0,0,1,-1]",
        "output": "Output: 0",
        "explanation": "Explanation: Since no enemy fort can be captured, 0 is returned."
      }
    ],
    "topics": [
      "Array",
      "Two Pointers"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Number of Great Partitions",
    "description": "You are given an array nums consisting of positive integers and an integer k.\nPartition the array into two ordered groups such that each element is in exactly one group. A partition is called great if the sum of elements of each group is greater than or equal to k.\nReturn the number of distinct great partitions. Since the answer may be too large, return it modulo 109 + 7.\nTwo partitions are considered distinct if some element nums[i] is in different groups in the two partitions.\n \nExample 1:\nInput: nums = [1,2,3,4], k = 4\nOutput: 6\nExplanation: The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and ([4], [1,2,3]).\n\nExample 2:\nInput: nums = [3,3,3], k = 4\nOutput: 0\nExplanation: There are no great partitions for this array.\n\nExample 3:\nInput: nums = [6,6], k = 2\nOutput: 2\nExplanation: We can either put nums[0] in the first partition or in the second partition.\nThe great partitions will be ([6], [6]) and ([6], [6]).\n\n \nConstraints:\n\n1 <= nums.length, k <= 1000\n1 <= nums[i] <= 109",
    "examples": [
      {
        "input": "Input: nums = [1,2,3,4], k = 4",
        "output": "Output: 6",
        "explanation": "Explanation: The great partitions are: ([1,2,3], [4]), ([1,3], [2,4]), ([1,4], [2,3]), ([2,3], [1,4]), ([2,4], [1,3]) and ([4], [1,2,3])."
      },
      {
        "input": "Input: nums = [3,3,3], k = 4",
        "output": "Output: 0",
        "explanation": "Explanation: There are no great partitions for this array."
      },
      {
        "input": "Input: nums = [6,6], k = 2",
        "output": "Output: 2",
        "explanation": "Explanation: We can either put nums[0] in the first partition or in the second partition."
      }
    ],
    "topics": [
      "Array",
      "Dynamic Programming"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Maximum Tastiness of Candy Basket",
    "description": "You are given an array of positive integers price where price[i] denotes the price of the ith candy and a positive integer k.\nThe store sells baskets of k distinct candies. The tastiness of a candy basket is the smallest absolute difference of the prices of any two candies in the basket.\nReturn the maximum tastiness of a candy basket.\n \nExample 1:\nInput: price = [13,5,1,8,21,2], k = 3\nOutput: 8\nExplanation: Choose the candies with the prices [13,5,21].\nThe tastiness of the candy basket is: min(|13 - 5|, |13 - 21|, |5 - 21|) = min(8, 8, 16) = 8.\nIt can be proven that 8 is the maximum tastiness that can be achieved.\n\nExample 2:\nInput: price = [1,3,1], k = 2\nOutput: 2\nExplanation: Choose the candies with the prices [1,3].\nThe tastiness of the candy basket is: min(|1 - 3|) = min(2) = 2.\nIt can be proven that 2 is the maximum tastiness that can be achieved.\n\nExample 3:\nInput: price = [7,7,7,7], k = 2\nOutput: 0\nExplanation: Choosing any two distinct candies from the candies we have will result in a tastiness of 0.\n\n \nConstraints:\n\n2 <= k <= price.length <= 105\n1 <= price[i] <= 109",
    "examples": [
      {
        "input": "Input: price = [13,5,1,8,21,2], k = 3",
        "output": "Output: 8",
        "explanation": "Explanation: Choose the candies with the prices [13,5,21]."
      },
      {
        "input": "Input: price = [1,3,1], k = 2",
        "output": "Output: 2",
        "explanation": "Explanation: Choose the candies with the prices [1,3]."
      },
      {
        "input": "Input: price = [7,7,7,7], k = 2",
        "output": "Output: 0",
        "explanation": "Explanation: Choosing any two distinct candies from the candies we have will result in a tastiness of 0."
      }
    ],
    "topics": [
      "Array",
      "Binary Search",
      "Sorting"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Take K of Each Character From Left and Right",
    "description": "You are given a string s consisting of the characters 'a', 'b', and 'c' and a non-negative integer k. Each minute, you may take either the leftmost character of s, or the rightmost character of s.\nReturn the minimum number of minutes needed for you to take at least k of each character, or return -1 if it is not possible to take k of each character.\n \nExample 1:\nInput: s = \"aabaaaacaabc\", k = 2\nOutput: 8\nExplanation: \nTake three characters from the left of s. You now have two 'a' characters, and one 'b' character.\nTake five characters from the right of s. You now have four 'a' characters, two 'b' characters, and two 'c' characters.\nA total of 3 + 5 = 8 minutes is needed.\nIt can be proven that 8 is the minimum number of minutes needed.\n\nExample 2:\nInput: s = \"a\", k = 1\nOutput: -1\nExplanation: It is not possible to take one 'b' or 'c' so return -1.\n\n \nConstraints:\n\n1 <= s.length <= 105\ns consists of only the letters 'a', 'b', and 'c'.\n0 <= k <= s.length",
    "examples": [
      {
        "input": "Input: s = \"aabaaaacaabc\", k = 2",
        "output": "Output: 8",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: s = \"a\", k = 1",
        "output": "Output: -1",
        "explanation": "Explanation: It is not possible to take one 'b' or 'c' so return -1."
      }
    ],
    "topics": [
      "Hash Table",
      "String",
      "Sliding Window"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Shortest Distance to Target String in a Circular Array",
    "description": "You are given a 0-indexed circular string array words and a string target. A circular array means that the array's end connects to the array's beginning.\n\nFormally, the next element of words[i] is words[(i + 1) % n] and the previous element of words[i] is words[(i - 1 + n) % n], where n is the length of words.\n\nStarting from startIndex, you can move to either the next word or the previous word with 1 step at a time.\nReturn the shortest distance needed to reach the string target. If the string target does not exist in words, return -1.\n \nExample 1:\nInput: words = [\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"], target = \"hello\", startIndex = 1\nOutput: 1\nExplanation: We start from index 1 and can reach \"hello\" by\n- moving 3 units to the right to reach index 4.\n- moving 2 units to the left to reach index 4.\n- moving 4 units to the right to reach index 0.\n- moving 1 unit to the left to reach index 0.\nThe shortest distance to reach \"hello\" is 1.\n\nExample 2:\nInput: words = [\"a\",\"b\",\"leetcode\"], target = \"leetcode\", startIndex = 0\nOutput: 1\nExplanation: We start from index 0 and can reach \"leetcode\" by\n- moving 2 units to the right to reach index 3.\n- moving 1 unit to the left to reach index 3.\nThe shortest distance to reach \"leetcode\" is 1.\nExample 3:\nInput: words = [\"i\",\"eat\",\"leetcode\"], target = \"ate\", startIndex = 0\nOutput: -1\nExplanation: Since \"ate\" does not exist in words, we return -1.\n\n \nConstraints:\n\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] and target consist of only lowercase English letters.\n0 <= startIndex < words.length",
    "examples": [
      {
        "input": "Input: words = [\"hello\",\"i\",\"am\",\"leetcode\",\"hello\"], target = \"hello\", startIndex = 1",
        "output": "Output: 1",
        "explanation": "Explanation: We start from index 1 and can reach \"hello\" by"
      },
      {
        "input": "Input: words = [\"a\",\"b\",\"leetcode\"], target = \"leetcode\", startIndex = 0",
        "output": "Output: 1",
        "explanation": "Explanation: We start from index 0 and can reach \"leetcode\" by"
      },
      {
        "input": "Input: words = [\"i\",\"eat\",\"leetcode\"], target = \"ate\", startIndex = 0",
        "output": "Output: -1",
        "explanation": "Explanation: Since \"ate\" does not exist in words, we return -1."
      }
    ],
    "topics": [
      "Array",
      "String"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Cycle Length Queries in a Tree",
    "description": "You are given an integer n. There is a complete binary tree with 2n - 1 nodes. The root of that tree is the node with the value 1, and every node with a value val in the range [1, 2n - 1 - 1] has two children where:\n\nThe left node has the value 2 * val, and\nThe right node has the value 2 * val + 1.\n\nYou are also given a 2D integer array queries of length m, where queries[i] = [ai, bi]. For each query, solve the following problem:\n\nAdd an edge between the nodes with values ai and bi.\nFind the length of the cycle in the graph.\nRemove the added edge between nodes with values ai and bi.\n\nNote that:\n\nA cycle is a path that starts and ends at the same node, and each edge in the path is visited only once.\nThe length of a cycle is the number of edges visited in the cycle.\nThere could be multiple edges between two nodes in the tree after adding the edge of the query.\n\nReturn an array answer of length m where answer[i] is the answer to the ith query.\n \nExample 1:\n\nInput: n = 3, queries = [[5,3],[4,7],[2,3]]\nOutput: [4,5,3]\nExplanation: The diagrams above show the tree of 23 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n- After adding the edge between nodes 3 and 5, the graph contains a cycle of nodes [5,2,1,3]. Thus answer to the first query is 4. We delete the added edge and process the next query.\n- After adding the edge between nodes 4 and 7, the graph contains a cycle of nodes [4,2,1,3,7]. Thus answer to the second query is 5. We delete the added edge and process the next query.\n- After adding the edge between nodes 2 and 3, the graph contains a cycle of nodes [2,1,3]. Thus answer to the third query is 3. We delete the added edge.\n\nExample 2:\n\nInput: n = 2, queries = [[1,2]]\nOutput: [2]\nExplanation: The diagram above shows the tree of 22 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge.\n- After adding the edge between nodes 1 and 2, the graph contains a cycle of nodes [2,1]. Thus answer for the first query is 2. We delete the added edge.\n\n \nConstraints:\n\n2 <= n <= 30\nm == queries.length\n1 <= m <= 105\nqueries[i].length == 2\n1 <= ai, bi <= 2n - 1\nai != bi",
    "examples": [
      {
        "input": "Input: n = 3, queries = [[5,3],[4,7],[2,3]]",
        "output": "Output: [4,5,3]",
        "explanation": "Explanation: The diagrams above show the tree of 23 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge."
      },
      {
        "input": "Input: n = 2, queries = [[1,2]]",
        "output": "Output: [2]",
        "explanation": "Explanation: The diagram above shows the tree of 22 - 1 nodes. Nodes colored in red describe the nodes in the cycle after adding the edge."
      }
    ],
    "topics": [
      "Tree",
      "Binary Tree"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Add Edges to Make Degrees of All Nodes Even",
    "description": "There is an undirected graph consisting of n nodes numbered from 1 to n. You are given the integer n and a 2D array edges where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi. The graph can be disconnected.\nYou can add at most two additional edges (possibly none) to this graph so that there are no repeated edges and no self-loops.\nReturn true if it is possible to make the degree of each node in the graph even, otherwise return false.\nThe degree of a node is the number of edges connected to it.\n \nExample 1:\n\nInput: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding an edge.\nEvery node in the resulting graph is connected to an even number of edges.\n\nExample 2:\n\nInput: n = 4, edges = [[1,2],[3,4]]\nOutput: true\nExplanation: The above diagram shows a valid way of adding two edges.\nExample 3:\n\nInput: n = 4, edges = [[1,2],[1,3],[1,4]]\nOutput: false\nExplanation: It is not possible to obtain a valid graph with adding at most 2 edges.\n \nConstraints:\n\n3 <= n <= 105\n2 <= edges.length <= 105\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere are no repeated edges.",
    "examples": [
      {
        "input": "Input: n = 5, edges = [[1,2],[2,3],[3,4],[4,2],[1,4],[2,5]]",
        "output": "Output: true",
        "explanation": "Explanation: The above diagram shows a valid way of adding an edge."
      },
      {
        "input": "Input: n = 4, edges = [[1,2],[3,4]]",
        "output": "Output: true",
        "explanation": "Explanation: The above diagram shows a valid way of adding two edges."
      },
      {
        "input": "Input: n = 4, edges = [[1,2],[1,3],[1,4]]",
        "output": "Output: false",
        "explanation": "Explanation: It is not possible to obtain a valid graph with adding at most 2 edges."
      }
    ],
    "topics": [
      "Hash Table",
      "Graph"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Smallest Value After Replacing With Sum of Prime Factors",
    "description": "You are given a positive integer n.\nContinuously replace n with the sum of its prime factors.\n\nNote that if a prime factor divides n multiple times, it should be included in the sum as many times as it divides n.\n\nReturn the smallest value n will take on.\n \nExample 1:\nInput: n = 15\nOutput: 5\nExplanation: Initially, n = 15.\n15 = 3 * 5, so replace n with 3 + 5 = 8.\n8 = 2 * 2 * 2, so replace n with 2 + 2 + 2 = 6.\n6 = 2 * 3, so replace n with 2 + 3 = 5.\n5 is the smallest value n will take on.\n\nExample 2:\nInput: n = 3\nOutput: 3\nExplanation: Initially, n = 3.\n3 is the smallest value n will take on.\n\n \nConstraints:\n\n2 <= n <= 105",
    "examples": [
      {
        "input": "Input: n = 15",
        "output": "Output: 5",
        "explanation": "Explanation: Initially, n = 15."
      },
      {
        "input": "Input: n = 3",
        "output": "Output: 3",
        "explanation": "Explanation: Initially, n = 3."
      }
    ],
    "topics": [
      "Math",
      "Number Theory"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Count Pairs Of Similar Strings",
    "description": "You are given a 0-indexed string array words.\nTwo strings are similar if they consist of the same characters.\n\nFor example, \"abca\" and \"cba\" are similar since both consist of characters 'a', 'b', and 'c'.\nHowever, \"abacba\" and \"bcfd\" are not similar since they do not consist of the same characters.\n\nReturn the number of pairs (i, j) such that 0 <= i < j <= word.length - 1 and the two strings words[i] and words[j] are similar.\n \nExample 1:\nInput: words = [\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"]\nOutput: 2\nExplanation: There are 2 pairs that satisfy the conditions:\n- i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'. \n- i = 3 and j = 4 : both words[3] and words[4] only consist of characters 'a', 'b', and 'c'. \n\nExample 2:\nInput: words = [\"aabb\",\"ab\",\"ba\"]\nOutput: 3\nExplanation: There are 3 pairs that satisfy the conditions:\n- i = 0 and j = 1 : both words[0] and words[1] only consist of characters 'a' and 'b'. \n- i = 0 and j = 2 : both words[0] and words[2] only consist of characters 'a' and 'b'.\n- i = 1 and j = 2 : both words[1] and words[2] only consist of characters 'a' and 'b'.\n\nExample 3:\nInput: words = [\"nba\",\"cba\",\"dba\"]\nOutput: 0\nExplanation: Since there does not exist any pair that satisfies the conditions, we return 0.\n \nConstraints:\n\n1 <= words.length <= 100\n1 <= words[i].length <= 100\nwords[i] consist of only lowercase English letters.",
    "examples": [
      {
        "input": "Input: words = [\"aba\",\"aabb\",\"abcd\",\"bac\",\"aabc\"]",
        "output": "Output: 2",
        "explanation": "Explanation: There are 2 pairs that satisfy the conditions:"
      },
      {
        "input": "Input: words = [\"aabb\",\"ab\",\"ba\"]",
        "output": "Output: 3",
        "explanation": "Explanation: There are 3 pairs that satisfy the conditions:"
      },
      {
        "input": "Input: words = [\"nba\",\"cba\",\"dba\"]",
        "output": "Output: 0",
        "explanation": "Explanation: Since there does not exist any pair that satisfies the conditions, we return 0."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "String"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Minimum Total Cost to Make Arrays Unequal",
    "description": "You are given two 0-indexed integer arrays nums1 and nums2, of equal length n.\nIn one operation, you can swap the values of any two indices of nums1. The cost of this operation is the sum of the indices.\nFind the minimum total cost of performing the given operation any number of times such that nums1[i] != nums2[i] for all 0 <= i <= n - 1 after performing all the operations.\nReturn the minimum total cost such that nums1 and nums2 satisfy the above condition. In case it is not possible, return -1.\n \nExample 1:\nInput: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 0 and 3, incurring cost = 0 + 3 = 3. Now, nums1 = [4,2,3,1,5]\n- Swap values at indices 1 and 2, incurring cost = 1 + 2 = 3. Now, nums1 = [4,3,2,1,5].\n- Swap values at indices 0 and 4, incurring cost = 0 + 4 = 4. Now, nums1 =[5,3,2,1,4].\nWe can see that for each index i, nums1[i] != nums2[i]. The cost required here is 10.\nNote that there are other ways to swap values, but it can be proven that it is not possible to obtain a cost less than 10.\n\nExample 2:\nInput: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]\nOutput: 10\nExplanation: \nOne of the ways we can perform the operations is:\n- Swap values at indices 2 and 3, incurring cost = 2 + 3 = 5. Now, nums1 = [2,2,1,2,3].\n- Swap values at indices 1 and 4, incurring cost = 1 + 4 = 5. Now, nums1 = [2,3,1,2,2].\nThe total cost needed here is 10, which is the minimum possible.\n\nExample 3:\nInput: nums1 = [1,2,2], nums2 = [1,2,2]\nOutput: -1\nExplanation: \nIt can be shown that it is not possible to satisfy the given conditions irrespective of the number of operations we perform.\nHence, we return -1.\n\n \nConstraints:\n\nn == nums1.length == nums2.length\n1 <= n <= 105\n1 <= nums1[i], nums2[i] <= n",
    "examples": [
      {
        "input": "Input: nums1 = [1,2,3,4,5], nums2 = [1,2,3,4,5]",
        "output": "Output: 10",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: nums1 = [2,2,2,1,3], nums2 = [1,2,2,3,3]",
        "output": "Output: 10",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: nums1 = [1,2,2], nums2 = [1,2,2]",
        "output": "Output: -1",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Greedy",
      "Counting"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Frog Jump II",
    "description": "You are given a 0-indexed integer array stones sorted in strictly increasing order representing the positions of stones in a river.\nA frog, initially on the first stone, wants to travel to the last stone and then return to the first stone. However, it can jump to any stone at most once.\nThe length of a jump is the absolute difference between the position of the stone the frog is currently on and the position of the stone to which the frog jumps.\n\nMore formally, if the frog is at stones[i] and is jumping to stones[j], the length of the jump is |stones[i] - stones[j]|.\n\nThe cost of a path is the maximum length of a jump among all jumps in the path.\nReturn the minimum cost of a path for the frog.\n \nExample 1:\n\nInput: stones = [0,2,5,6,7]\nOutput: 5\nExplanation: The above figure represents one of the optimal paths the frog can take.\nThe cost of this path is 5, which is the maximum length of a jump.\nSince it is not possible to achieve a cost of less than 5, we return it.\n\nExample 2:\n\nInput: stones = [0,3,9]\nOutput: 9\nExplanation: \nThe frog can jump directly to the last stone and come back to the first stone. \nIn this case, the length of each jump will be 9. The cost for the path will be max(9, 9) = 9.\nIt can be shown that this is the minimum achievable cost.\n\n \nConstraints:\n\n2 <= stones.length <= 105\n0 <= stones[i] <= 109\nstones[0] == 0\nstones is sorted in a strictly increasing order.",
    "examples": [
      {
        "input": "Input: stones = [0,2,5,6,7]",
        "output": "Output: 5",
        "explanation": "Explanation: The above figure represents one of the optimal paths the frog can take."
      },
      {
        "input": "Input: stones = [0,3,9]",
        "output": "Output: 9",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Binary Search",
      "Greedy"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Maximum Star Sum of a Graph",
    "description": "There is an undirected graph consisting of n nodes numbered from 0 to n - 1. You are given a 0-indexed integer array vals of length n where vals[i] denotes the value of the ith node.\nYou are also given a 2D integer array edges where edges[i] = [ai, bi] denotes that there exists an undirected edge connecting nodes ai and bi.\nA star graph is a subgraph of the given graph having a center node containing 0 or more neighbors. In other words, it is a subset of edges of the given graph such that there exists a common node for all edges.\nThe image below shows star graphs with 3 and 4 neighbors respectively, centered at the blue node.\n\nThe star sum is the sum of the values of all the nodes present in the star graph.\nGiven an integer k, return the maximum star sum of a star graph containing at most k edges.\n \nExample 1:\n\nInput: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2\nOutput: 16\nExplanation: The above diagram represents the input graph.\nThe star graph with the maximum star sum is denoted by blue. It is centered at 3 and includes its neighbors 1 and 4.\nIt can be shown it is not possible to get a star graph with a sum greater than 16.\n\nExample 2:\nInput: vals = [-5], edges = [], k = 0\nOutput: -5\nExplanation: There is only one possible star graph, which is node 0 itself.\nHence, we return -5.\n\n \nConstraints:\n\nn == vals.length\n1 <= n <= 105\n-104 <= vals[i] <= 104\n0 <= edges.length <= min(n * (n - 1) / 2, 105)\nedges[i].length == 2\n0 <= ai, bi <= n - 1\nai != bi\n0 <= k <= n - 1",
    "examples": [
      {
        "input": "Input: vals = [1,2,3,4,10,-10,-20], edges = [[0,1],[1,2],[1,3],[3,4],[3,5],[3,6]], k = 2",
        "output": "Output: 16",
        "explanation": "Explanation: The above diagram represents the input graph."
      },
      {
        "input": "Input: vals = [-5], edges = [], k = 0",
        "output": "Output: -5",
        "explanation": "Explanation: There is only one possible star graph, which is node 0 itself."
      }
    ],
    "topics": [
      "Array",
      "Greedy",
      "Graph",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Maximum Value of a String in an Array",
    "description": "The value of an alphanumeric string can be defined as:\n\nThe numeric representation of the string in base 10, if it comprises of digits only.\nThe length of the string, otherwise.\n\nGiven an array strs of alphanumeric strings, return the maximum value of any string in strs.\n \nExample 1:\nInput: strs = [\"alic3\",\"bob\",\"3\",\"4\",\"00000\"]\nOutput: 5\nExplanation: \n- \"alic3\" consists of both letters and digits, so its value is its length, i.e. 5.\n- \"bob\" consists only of letters, so its value is also its length, i.e. 3.\n- \"3\" consists only of digits, so its value is its numeric equivalent, i.e. 3.\n- \"4\" also consists only of digits, so its value is 4.\n- \"00000\" consists only of digits, so its value is 0.\nHence, the maximum value is 5, of \"alic3\".\n\nExample 2:\nInput: strs = [\"1\",\"01\",\"001\",\"0001\"]\nOutput: 1\nExplanation: \nEach string in the array has value 1. Hence, we return 1.\n\n \nConstraints:\n\n1 <= strs.length <= 100\n1 <= strs[i].length <= 9\nstrs[i] consists of only lowercase English letters and digits.",
    "examples": [
      {
        "input": "Input: strs = [\"alic3\",\"bob\",\"3\",\"4\",\"00000\"]",
        "output": "Output: 5",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: strs = [\"1\",\"01\",\"001\",\"0001\"]",
        "output": "Output: 1",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "String"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Maximum Number of Points From Grid Queries",
    "description": "You are given an m x n integer matrix grid and an array queries of size k.\nFind an array answer of size k such that for each integer queries[i] you start in the top left cell of the matrix and repeat the following process:\n\nIf queries[i] is strictly greater than the value of the current cell that you are in, then you get one point if it is your first time visiting this cell, and you can move to any adjacent cell in all 4 directions: up, down, left, and right.\nOtherwise, you do not get any points, and you end this process.\n\nAfter the process, answer[i] is the maximum number of points you can get. Note that for each query you are allowed to visit the same cell multiple times.\nReturn the resulting array answer.\n \nExample 1:\n\nInput: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]\nOutput: [5,8,1]\nExplanation: The diagrams above show which cells we visit to get points for each query.\nExample 2:\n\nInput: grid = [[5,2,1],[1,1,2]], queries = [3]\nOutput: [0]\nExplanation: We can not get any points because the value of the top left cell is already greater than or equal to 3.\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n2 <= m, n <= 1000\n4 <= m * n <= 105\nk == queries.length\n1 <= k <= 104\n1 <= grid[i][j], queries[i] <= 106",
    "examples": [
      {
        "input": "Input: grid = [[1,2,3],[2,5,7],[3,5,1]], queries = [5,6,2]",
        "output": "Output: [5,8,1]",
        "explanation": "Explanation: The diagrams above show which cells we visit to get points for each query."
      },
      {
        "input": "Input: grid = [[5,2,1],[1,1,2]], queries = [3]",
        "output": "Output: [0]",
        "explanation": "Explanation: We can not get any points because the value of the top left cell is already greater than or equal to 3."
      }
    ],
    "topics": [
      "Array",
      "Breadth-First Search",
      "Union Find",
      "Sorting",
      "Heap (Priority Queue)"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Design Memory Allocator",
    "description": "You are given an integer n representing the size of a 0-indexed memory array. All memory units are initially free.\nYou have a memory allocator with the following functionalities:\n\nAllocate a block of size consecutive free memory units and assign it the id mID.\nFree all memory units with the given id mID.\n\nNote that:\n\nMultiple blocks can be allocated to the same mID.\nYou should free all the memory units with mID, even if they were allocated in different blocks.\n\nImplement the Allocator class:\n\nAllocator(int n) Initializes an Allocator object with a memory array of size n.\nint allocate(int size, int mID) Find the leftmost block of size consecutive free memory units and allocate it with the id mID. Return the block's first index. If such a block does not exist, return -1.\nint free(int mID) Free all memory units with the id mID. Return the number of memory units you have freed.\n\n \nExample 1:\nInput\n[\"Allocator\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"free\"]\n[[10], [1, 1], [1, 2], [1, 3], [2], [3, 4], [1, 1], [1, 1], [1], [10, 2], [7]]\nOutput\n[null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]\n\nExplanation\nAllocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free.\nloc.allocate(1, 1); // The leftmost block's first index is 0. The memory array becomes [1,_,_,_,_,_,_,_,_,_]. We return 0.\nloc.allocate(1, 2); // The leftmost block's first index is 1. The memory array becomes [1,2,_,_,_,_,_,_,_,_]. We return 1.\nloc.allocate(1, 3); // The leftmost block's first index is 2. The memory array becomes [1,2,3,_,_,_,_,_,_,_]. We return 2.\nloc.free(2); // Free all memory units with mID 2. The memory array becomes [1,_, 3,_,_,_,_,_,_,_]. We return 1 since there is only 1 unit with mID 2.\nloc.allocate(3, 4); // The leftmost block's first index is 3. The memory array becomes [1,_,3,4,4,4,_,_,_,_]. We return 3.\nloc.allocate(1, 1); // The leftmost block's first index is 1. The memory array becomes [1,1,3,4,4,4,_,_,_,_]. We return 1.\nloc.allocate(1, 1); // The leftmost block's first index is 6. The memory array becomes [1,1,3,4,4,4,1,_,_,_]. We return 6.\nloc.free(1); // Free all memory units with mID 1. The memory array becomes [_,_,3,4,4,4,_,_,_,_]. We return 3 since there are 3 units with mID 1.\nloc.allocate(10, 2); // We can not find any free block with 10 consecutive free memory units, so we return -1.\nloc.free(7); // Free all memory units with mID 7. The memory array remains the same since there is no memory unit with mID 7. We return 0.\n\n \nConstraints:\n\n1 <= n, size, mID <= 1000\nAt most 1000 calls will be made to allocate and free.",
    "examples": [
      {
        "input": "Input\n[\"Allocator\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"allocate\", \"allocate\", \"free\", \"allocate\", \"free\"]",
        "output": "Output\n[null, 0, 1, 2, 1, 3, 1, 6, 3, -1, 0]",
        "explanation": "Explanation\nAllocator loc = new Allocator(10); // Initialize a memory array of size 10. All memory units are initially free."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Design",
      "Simulation"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Longest Square Streak in an Array",
    "description": "You are given an integer array nums. A subsequence of nums is called a square streak if:\n\nThe length of the subsequence is at least 2, and\nafter sorting the subsequence, each element (except the first element) is the square of the previous number.\n\nReturn the length of the longest square streak in nums, or return -1 if there is no square streak.\nA subsequence is an array that can be derived from another array by deleting some or no elements without changing the order of the remaining elements.\n \nExample 1:\nInput: nums = [4,3,6,16,8,2]\nOutput: 3\nExplanation: Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16].\n- 4 = 2 * 2.\n- 16 = 4 * 4.\nTherefore, [4,16,2] is a square streak.\nIt can be shown that every subsequence of length 4 is not a square streak.\n\nExample 2:\nInput: nums = [2,3,5,6,7]\nOutput: -1\nExplanation: There is no square streak in nums so return -1.\n\n \nConstraints:\n\n2 <= nums.length <= 105\n2 <= nums[i] <= 105",
    "examples": [
      {
        "input": "Input: nums = [4,3,6,16,8,2]",
        "output": "Output: 3",
        "explanation": "Explanation: Choose the subsequence [4,16,2]. After sorting it, it becomes [2,4,16]."
      },
      {
        "input": "Input: nums = [2,3,5,6,7]",
        "output": "Output: -1",
        "explanation": "Explanation: There is no square streak in nums so return -1."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Binary Search",
      "Dynamic Programming",
      "Sorting"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Delete Greatest Value in Each Row",
    "description": "You are given an m x n matrix grid consisting of positive integers.\nPerform the following operation until grid becomes empty:\n\nDelete the element with the greatest value from each row. If multiple such elements exist, delete any of them.\nAdd the maximum of deleted elements to the answer.\n\nNote that the number of columns decreases by one after each operation.\nReturn the answer after performing the operations described above.\n \nExample 1:\n\nInput: grid = [[1,2,4],[3,3,1]]\nOutput: 8\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 4 from the first row and 3 from the second row (notice that, there are two cells with value 3 and we can remove any of them). We add 4 to the answer.\n- In the second operation, we remove 2 from the first row and 3 from the second row. We add 3 to the answer.\n- In the third operation, we remove 1 from the first row and 1 from the second row. We add 1 to the answer.\nThe final answer = 4 + 3 + 1 = 8.\n\nExample 2:\n\nInput: grid = [[10]]\nOutput: 10\nExplanation: The diagram above shows the removed values in each step.\n- In the first operation, we remove 10 from the first row. We add 10 to the answer.\nThe final answer = 10.\n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 50\n1 <= grid[i][j] <= 100",
    "examples": [
      {
        "input": "Input: grid = [[1,2,4],[3,3,1]]",
        "output": "Output: 8",
        "explanation": "Explanation: The diagram above shows the removed values in each step."
      },
      {
        "input": "Input: grid = [[10]]",
        "output": "Output: 10",
        "explanation": "Explanation: The diagram above shows the removed values in each step."
      }
    ],
    "topics": [
      "Array",
      "Sorting",
      "Matrix"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Divide Nodes Into the Maximum Number of Groups",
    "description": "You are given a positive integer n representing the number of nodes in an undirected graph. The nodes are labeled from 1 to n.\nYou are also given a 2D integer array edges, where edges[i] = [ai, bi] indicates that there is a bidirectional edge between nodes ai and bi. Notice that the given graph may be disconnected.\nDivide the nodes of the graph into m groups (1-indexed) such that:\n\nEach node in the graph belongs to exactly one group.\nFor every pair of nodes in the graph that are connected by an edge [ai, bi], if ai belongs to the group with index x, and bi belongs to the group with index y, then |y - x| = 1.\n\nReturn the maximum number of groups (i.e., maximum m) into which you can divide the nodes. Return -1 if it is impossible to group the nodes with the given conditions.\n \nExample 1:\n\nInput: n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]\nOutput: 4\nExplanation: As shown in the image we:\n- Add node 5 to the first group.\n- Add node 1 to the second group.\n- Add nodes 2 and 4 to the third group.\n- Add nodes 3 and 6 to the fourth group.\nWe can see that every edge is satisfied.\nIt can be shown that that if we create a fifth group and move any node from the third or fourth group to it, at least on of the edges will not be satisfied.\n\nExample 2:\nInput: n = 3, edges = [[1,2],[2,3],[3,1]]\nOutput: -1\nExplanation: If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied.\nIt can be shown that no grouping is possible.\n\n \nConstraints:\n\n1 <= n <= 500\n1 <= edges.length <= 104\nedges[i].length == 2\n1 <= ai, bi <= n\nai != bi\nThere is at most one edge between any pair of vertices.",
    "examples": [
      {
        "input": "Input: n = 6, edges = [[1,2],[1,4],[1,5],[2,6],[2,3],[4,6]]",
        "output": "Output: 4",
        "explanation": "Explanation: As shown in the image we:"
      },
      {
        "input": "Input: n = 3, edges = [[1,2],[2,3],[3,1]]",
        "output": "Output: -1",
        "explanation": "Explanation: If we add node 1 to the first group, node 2 to the second group, and node 3 to the third group to satisfy the first two edges, we can see that the third edge will not be satisfied."
      }
    ],
    "topics": [
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Minimum Score of a Path Between Two Cities",
    "description": "You are given a positive integer n representing n cities numbered from 1 to n. You are also given a 2D array roads where roads[i] = [ai, bi, distancei] indicates that there is a bidirectional road between cities ai and bi with a distance equal to distancei. The cities graph is not necessarily connected.\nThe score of a path between two cities is defined as the minimum distance of a road in this path.\nReturn the minimum possible score of a path between cities 1 and n.\nNote:\n\nA path is a sequence of roads between two cities.\nIt is allowed for a path to contain the same road multiple times, and you can visit cities 1 and n multiple times along the path.\nThe test cases are generated such that there is at least one path between 1 and n.\n\n \nExample 1:\n\nInput: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]\nOutput: 5\nExplanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5.\nIt can be shown that no other path has less score.\n\nExample 2:\n\nInput: n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]\nOutput: 2\nExplanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2.\n\n \nConstraints:\n\n2 <= n <= 105\n1 <= roads.length <= 105\nroads[i].length == 3\n1 <= ai, bi <= n\nai != bi\n1 <= distancei <= 104\nThere are no repeated edges.\nThere is at least one path between 1 and n.",
    "examples": [
      {
        "input": "Input: n = 4, roads = [[1,2,9],[2,3,6],[2,4,5],[1,4,7]]",
        "output": "Output: 5",
        "explanation": "Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 4. The score of this path is min(9,5) = 5."
      },
      {
        "input": "Input: n = 4, roads = [[1,2,2],[1,3,4],[3,4,7]]",
        "output": "Output: 2",
        "explanation": "Explanation: The path from city 1 to 4 with the minimum score is: 1 -> 2 -> 1 -> 3 -> 4. The score of this path is min(2,2,4,7) = 2."
      }
    ],
    "topics": [
      "Depth-First Search",
      "Breadth-First Search",
      "Union Find",
      "Graph"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Divide Players Into Teams of Equal Skill",
    "description": "You are given a positive integer array skill of even length n where skill[i] denotes the skill of the ith player. Divide the players into n / 2 teams of size 2 such that the total skill of each team is equal.\nThe chemistry of a team is equal to the product of the skills of the players on that team.\nReturn the sum of the chemistry of all the teams, or return -1 if there is no way to divide the players into teams such that the total skill of each team is equal.\n \nExample 1:\nInput: skill = [3,2,5,1,3,4]\nOutput: 22\nExplanation: \nDivide the players into the following teams: (1, 5), (2, 4), (3, 3), where each team has a total skill of 6.\nThe sum of the chemistry of all the teams is: 1 * 5 + 2 * 4 + 3 * 3 = 5 + 8 + 9 = 22.\n\nExample 2:\nInput: skill = [3,4]\nOutput: 12\nExplanation: \nThe two players form a team with a total skill of 7.\nThe chemistry of the team is 3 * 4 = 12.\n\nExample 3:\nInput: skill = [1,1,2,3]\nOutput: -1\nExplanation: \nThere is no way to divide the players into teams such that the total skill of each team is equal.\n\n \nConstraints:\n\n2 <= skill.length <= 105\nskill.length is even.\n1 <= skill[i] <= 1000",
    "examples": [
      {
        "input": "Input: skill = [3,2,5,1,3,4]",
        "output": "Output: 22",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: skill = [3,4]",
        "output": "Output: 12",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: skill = [1,1,2,3]",
        "output": "Output: -1",
        "explanation": "Explanation: "
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Two Pointers",
      "Sorting"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Circular Sentence",
    "description": "A sentence is a list of words that are separated by a single space with no leading or trailing spaces.\n\nFor example, \"Hello World\", \"HELLO\", \"hello world hello world\" are all sentences.\n\nWords consist of only uppercase and lowercase English letters. Uppercase and lowercase English letters are considered different.\nA sentence is circular if:\n\nThe last character of a word is equal to the first character of the next word.\nThe last character of the last word is equal to the first character of the first word.\n\nFor example, \"leetcode exercises sound delightful\", \"eetcode\", \"leetcode eats soul\" are all circular sentences. However, \"Leetcode is cool\", \"happy Leetcode\", \"Leetcode\" and \"I like Leetcode\" are not circular sentences.\nGiven a string sentence, return true if it is circular. Otherwise, return false.\n \nExample 1:\nInput: sentence = \"leetcode exercises sound delightful\"\nOutput: true\nExplanation: The words in sentence are [\"leetcode\", \"exercises\", \"sound\", \"delightful\"].\n- leetcode's last character is equal to exercises's first character.\n- exercises's last character is equal to sound's first character.\n- sound's last character is equal to delightful's first character.\n- delightful's last character is equal to leetcode's first character.\nThe sentence is circular.\nExample 2:\nInput: sentence = \"eetcode\"\nOutput: true\nExplanation: The words in sentence are [\"eetcode\"].\n- eetcode's last character is equal to eetcode's first character.\nThe sentence is circular.\nExample 3:\nInput: sentence = \"Leetcode is cool\"\nOutput: false\nExplanation: The words in sentence are [\"Leetcode\", \"is\", \"cool\"].\n- Leetcode's last character is not equal to is's first character.\nThe sentence is not circular.\n \nConstraints:\n\n1 <= sentence.length <= 500\nsentence consist of only lowercase and uppercase English letters and spaces.\nThe words in sentence are separated by a single space.\nThere are no leading or trailing spaces.",
    "examples": [
      {
        "input": "Input: sentence = \"leetcode exercises sound delightful\"",
        "output": "Output: true",
        "explanation": "Explanation: The words in sentence are [\"leetcode\", \"exercises\", \"sound\", \"delightful\"]."
      },
      {
        "input": "Input: sentence = \"eetcode\"",
        "output": "Output: true",
        "explanation": "Explanation: The words in sentence are [\"eetcode\"]."
      },
      {
        "input": "Input: sentence = \"Leetcode is cool\"",
        "output": "Output: false",
        "explanation": "Explanation: The words in sentence are [\"Leetcode\", \"is\", \"cool\"]."
      }
    ],
    "topics": [
      "String"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Count Palindromic Subsequences",
    "description": "Given a string of digits s, return the number of palindromic subsequences of s having length 5. Since the answer may be very large, return it modulo 109 + 7.\nNote:\n\nA string is palindromic if it reads the same forward and backward.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n\n \nExample 1:\nInput: s = \"103301\"\nOutput: 2\nExplanation: \nThere are 6 possible subsequences of length 5: \"10330\",\"10331\",\"10301\",\"10301\",\"13301\",\"03301\". \nTwo of them (both equal to \"10301\") are palindromic.\n\nExample 2:\nInput: s = \"0000000\"\nOutput: 21\nExplanation: All 21 subsequences are \"00000\", which is palindromic.\n\nExample 3:\nInput: s = \"9999900000\"\nOutput: 2\nExplanation: The only two palindromic subsequences are \"99999\" and \"00000\".\n\n \nConstraints:\n\n1 <= s.length <= 104\ns consists of digits.",
    "examples": [
      {
        "input": "Input: s = \"103301\"",
        "output": "Output: 2",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: s = \"0000000\"",
        "output": "Output: 21",
        "explanation": "Explanation: All 21 subsequences are \"00000\", which is palindromic."
      },
      {
        "input": "Input: s = \"9999900000\"",
        "output": "Output: 2",
        "explanation": "Explanation: The only two palindromic subsequences are \"99999\" and \"00000\"."
      }
    ],
    "topics": [
      "String",
      "Dynamic Programming"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Minimum Penalty for a Shop",
    "description": "You are given the customer visit log of a shop represented by a 0-indexed string customers consisting only of characters 'N' and 'Y':\n\nif the ith character is 'Y', it means that customers come at the ith hour\nwhereas 'N' indicates that no customers come at the ith hour.\n\nIf the shop closes at the jth hour (0 <= j <= n), the penalty is calculated as follows:\n\nFor every hour when the shop is open and no customers come, the penalty increases by 1.\nFor every hour when the shop is closed and customers come, the penalty increases by 1.\n\nReturn the earliest hour at which the shop must be closed to incur a minimum penalty.\nNote that if a shop closes at the jth hour, it means the shop is closed at the hour j.\n \nExample 1:\nInput: customers = \"YYNY\"\nOutput: 2\nExplanation: \n- Closing the shop at the 0th hour incurs in 1+1+0+1 = 3 penalty.\n- Closing the shop at the 1st hour incurs in 0+1+0+1 = 2 penalty.\n- Closing the shop at the 2nd hour incurs in 0+0+0+1 = 1 penalty.\n- Closing the shop at the 3rd hour incurs in 0+0+1+1 = 2 penalty.\n- Closing the shop at the 4th hour incurs in 0+0+1+0 = 1 penalty.\nClosing the shop at 2nd or 4th hour gives a minimum penalty. Since 2 is earlier, the optimal closing time is 2.\n\nExample 2:\nInput: customers = \"NNNNN\"\nOutput: 0\nExplanation: It is best to close the shop at the 0th hour as no customers arrive.\nExample 3:\nInput: customers = \"YYYY\"\nOutput: 4\nExplanation: It is best to close the shop at the 4th hour as customers arrive at each hour.\n\n \nConstraints:\n\n1 <= customers.length <= 105\ncustomers consists only of characters 'Y' and 'N'.",
    "examples": [
      {
        "input": "Input: customers = \"YYNY\"",
        "output": "Output: 2",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: customers = \"NNNNN\"",
        "output": "Output: 0",
        "explanation": "Explanation: It is best to close the shop at the 0th hour as no customers arrive."
      },
      {
        "input": "Input: customers = \"YYYY\"",
        "output": "Output: 4",
        "explanation": "Explanation: It is best to close the shop at the 4th hour as customers arrive at each hour."
      }
    ],
    "topics": [
      "String",
      "Prefix Sum"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Minimum Cuts to Divide a Circle",
    "description": "A valid cut in a circle can be:\n\nA cut that is represented by a straight line that touches two points on the edge of the circle and passes through its center, or\nA cut that is represented by a straight line that touches one point on the edge of the circle and its center.\n\nSome valid and invalid cuts are shown in the figures below.\n\nGiven the integer n, return the minimum number of cuts needed to divide a circle into n equal slices.\n \nExample 1:\n\nInput: n = 4\nOutput: 2\nExplanation: \nThe above figure shows how cutting the circle twice through the middle divides it into 4 equal slices.\n\nExample 2:\n\nInput: n = 3\nOutput: 3\nExplanation:\nAt least 3 cuts are needed to divide the circle into 3 equal slices. \nIt can be shown that less than 3 cuts cannot result in 3 slices of equal size and shape.\nAlso note that the first cut will not divide the circle into distinct parts.\n\n \nConstraints:\n\n1 <= n <= 100",
    "examples": [
      {
        "input": "Input: n = 4",
        "output": "Output: 2",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: n = 3",
        "output": "Output: 3",
        "explanation": ""
      }
    ],
    "topics": [
      "Math",
      "Geometry"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Count Subarrays With Median K",
    "description": "You are given an array nums of size n consisting of distinct integers from 1 to n and a positive integer k.\nReturn the number of non-empty subarrays in nums that have a median equal to k.\nNote:\n\nThe median of an array is the middle element after sorting the array in ascending order. If the array is of even length, the median is the left middle element.\n\n\t\nFor example, the median of [2,3,1,4] is 2, and the median of [8,4,3,5,1] is 4.\n\n\nA subarray is a contiguous part of an array.\n\n \nExample 1:\nInput: nums = [3,2,1,4,5], k = 4\nOutput: 3\nExplanation: The subarrays that have a median equal to 4 are: [4], [4,5] and [1,4,5].\n\nExample 2:\nInput: nums = [2,3,1], k = 3\nOutput: 1\nExplanation: [3] is the only subarray that has a median equal to 3.\n\n \nConstraints:\n\nn == nums.length\n1 <= n <= 105\n1 <= nums[i], k <= n\nThe integers in nums are distinct.",
    "examples": [
      {
        "input": "Input: nums = [3,2,1,4,5], k = 4",
        "output": "Output: 3",
        "explanation": "Explanation: The subarrays that have a median equal to 4 are: [4], [4,5] and [1,4,5]."
      },
      {
        "input": "Input: nums = [2,3,1], k = 3",
        "output": "Output: 1",
        "explanation": "Explanation: [3] is the only subarray that has a median equal to 3."
      }
    ],
    "topics": [
      "Array",
      "Hash Table",
      "Prefix Sum"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Remove Nodes From Linked List",
    "description": "You are given the head of a linked list.\nRemove every node which has a node with a strictly greater value anywhere to the right side of it.\nReturn the head of the modified linked list.\n \nExample 1:\n\nInput: head = [5,2,13,3,8]\nOutput: [13,8]\nExplanation: The nodes that should be removed are 5, 2 and 3.\n- Node 13 is to the right of node 5.\n- Node 13 is to the right of node 2.\n- Node 8 is to the right of node 3.\n\nExample 2:\nInput: head = [1,1,1,1]\nOutput: [1,1,1,1]\nExplanation: Every node has value 1, so no nodes are removed.\n\n \nConstraints:\n\nThe number of the nodes in the given list is in the range [1, 105].\n1 <= Node.val <= 105",
    "examples": [
      {
        "input": "Input: head = [5,2,13,3,8]",
        "output": "Output: [13,8]",
        "explanation": "Explanation: The nodes that should be removed are 5, 2 and 3."
      },
      {
        "input": "Input: head = [1,1,1,1]",
        "output": "Output: [1,1,1,1]",
        "explanation": "Explanation: Every node has value 1, so no nodes are removed."
      }
    ],
    "topics": [
      "Linked List",
      "Stack",
      "Recursion",
      "Monotonic Stack"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Append Characters to String to Make Subsequence",
    "description": "You are given two strings s and t consisting of only lowercase English letters.\nReturn the minimum number of characters that need to be appended to the end of s so that t becomes a subsequence of s.\nA subsequence is a string that can be derived from another string by deleting some or no characters without changing the order of the remaining characters.\n \nExample 1:\nInput: s = \"coaching\", t = \"coding\"\nOutput: 4\nExplanation: Append the characters \"ding\" to the end of s so that s = \"coachingding\".\nNow, t is a subsequence of s (\"coachingding\").\nIt can be shown that appending any 3 characters to the end of s will never make t a subsequence.\n\nExample 2:\nInput: s = \"abcde\", t = \"a\"\nOutput: 0\nExplanation: t is already a subsequence of s (\"abcde\").\n\nExample 3:\nInput: s = \"z\", t = \"abcde\"\nOutput: 5\nExplanation: Append the characters \"abcde\" to the end of s so that s = \"zabcde\".\nNow, t is a subsequence of s (\"zabcde\").\nIt can be shown that appending any 4 characters to the end of s will never make t a subsequence.\n\n \nConstraints:\n\n1 <= s.length, t.length <= 105\ns and t consist only of lowercase English letters.",
    "examples": [
      {
        "input": "Input: s = \"coaching\", t = \"coding\"",
        "output": "Output: 4",
        "explanation": "Explanation: Append the characters \"ding\" to the end of s so that s = \"coachingding\"."
      },
      {
        "input": "Input: s = \"abcde\", t = \"a\"",
        "output": "Output: 0",
        "explanation": "Explanation: t is already a subsequence of s (\"abcde\")."
      },
      {
        "input": "Input: s = \"z\", t = \"abcde\"",
        "output": "Output: 5",
        "explanation": "Explanation: Append the characters \"abcde\" to the end of s so that s = \"zabcde\"."
      }
    ],
    "topics": [
      "Two Pointers",
      "String",
      "Greedy"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Find the Pivot Integer",
    "description": "Given a positive integer n, find the pivot integer x such that:\n\nThe sum of all elements between 1 and x inclusively equals the sum of all elements between x and n inclusively.\n\nReturn the pivot integer x. If no such integer exists, return -1. It is guaranteed that there will be at most one pivot index for the given input.\n \nExample 1:\nInput: n = 8\nOutput: 6\nExplanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21.\n\nExample 2:\nInput: n = 1\nOutput: 1\nExplanation: 1 is the pivot integer since: 1 = 1.\n\nExample 3:\nInput: n = 4\nOutput: -1\nExplanation: It can be proved that no such integer exist.\n\n \nConstraints:\n\n1 <= n <= 1000",
    "examples": [
      {
        "input": "Input: n = 8",
        "output": "Output: 6",
        "explanation": "Explanation: 6 is the pivot integer since: 1 + 2 + 3 + 4 + 5 + 6 = 6 + 7 + 8 = 21."
      },
      {
        "input": "Input: n = 1",
        "output": "Output: 1",
        "explanation": "Explanation: 1 is the pivot integer since: 1 = 1."
      },
      {
        "input": "Input: n = 4",
        "output": "Output: -1",
        "explanation": "Explanation: It can be proved that no such integer exist."
      }
    ],
    "topics": [
      "Math",
      "Prefix Sum"
    ],
    "difficulty": "Easy"
  },
  {
    "title": "Number of Beautiful Partitions",
    "description": "You are given a string s that consists of the digits '1' to '9' and two integers k and minLength.\nA partition of s is called beautiful if:\n\ns is partitioned into k non-intersecting substrings.\nEach substring has a length of at least minLength.\nEach substring starts with a prime digit and ends with a non-prime digit. Prime digits are '2', '3', '5', and '7', and the rest of the digits are non-prime.\n\nReturn the number of beautiful partitions of s. Since the answer may be very large, return it modulo 109 + 7.\nA substring is a contiguous sequence of characters within a string.\n \nExample 1:\nInput: s = \"23542185131\", k = 3, minLength = 2\nOutput: 3\nExplanation: There exists three ways to create a beautiful partition:\n\"2354 | 218 | 5131\"\n\"2354 | 21851 | 31\"\n\"2354218 | 51 | 31\"\n\nExample 2:\nInput: s = \"23542185131\", k = 3, minLength = 3\nOutput: 1\nExplanation: There exists one way to create a beautiful partition: \"2354 | 218 | 5131\".\n\nExample 3:\nInput: s = \"3312958\", k = 3, minLength = 1\nOutput: 1\nExplanation: There exists one way to create a beautiful partition: \"331 | 29 | 58\".\n\n \nConstraints:\n\n1 <= k, minLength <= s.length <= 1000\ns consists of the digits '1' to '9'.",
    "examples": [
      {
        "input": "Input: s = \"23542185131\", k = 3, minLength = 2",
        "output": "Output: 3",
        "explanation": "Explanation: There exists three ways to create a beautiful partition:"
      },
      {
        "input": "Input: s = \"23542185131\", k = 3, minLength = 3",
        "output": "Output: 1",
        "explanation": "Explanation: There exists one way to create a beautiful partition: \"2354 | 218 | 5131\"."
      },
      {
        "input": "Input: s = \"3312958\", k = 3, minLength = 1",
        "output": "Output: 1",
        "explanation": "Explanation: There exists one way to create a beautiful partition: \"331 | 29 | 58\"."
      }
    ],
    "topics": [
      "String",
      "Dynamic Programming"
    ],
    "difficulty": "Hard"
  },
  {
    "title": "Minimum Fuel Cost to Report to the Capital",
    "description": "There is a tree (i.e., a connected, undirected graph with no cycles) structure country network consisting of n cities numbered from 0 to n - 1 and exactly n - 1 roads. The capital city is city 0. You are given a 2D integer array roads where roads[i] = [ai, bi] denotes that there exists a bidirectional road connecting cities ai and bi.\nThere is a meeting for the representatives of each city. The meeting is in the capital city.\nThere is a car in each city. You are given an integer seats that indicates the number of seats in each car.\nA representative can use the car in their city to travel or change the car and ride with another representative. The cost of traveling between two cities is one liter of fuel.\nReturn the minimum number of liters of fuel to reach the capital city.\n \nExample 1:\n\nInput: roads = [[0,1],[0,2],[0,3]], seats = 5\nOutput: 3\nExplanation: \n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative2 goes directly to the capital with 1 liter of fuel.\n- Representative3 goes directly to the capital with 1 liter of fuel.\nIt costs 3 liters of fuel at minimum. \nIt can be proven that 3 is the minimum number of liters of fuel needed.\n\nExample 2:\n\nInput: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2\nOutput: 7\nExplanation: \n- Representative2 goes directly to city 3 with 1 liter of fuel.\n- Representative2 and representative3 go together to city 1 with 1 liter of fuel.\n- Representative2 and representative3 go together to the capital with 1 liter of fuel.\n- Representative1 goes directly to the capital with 1 liter of fuel.\n- Representative5 goes directly to the capital with 1 liter of fuel.\n- Representative6 goes directly to city 4 with 1 liter of fuel.\n- Representative4 and representative6 go together to the capital with 1 liter of fuel.\nIt costs 7 liters of fuel at minimum. \nIt can be proven that 7 is the minimum number of liters of fuel needed.\n\nExample 3:\n\nInput: roads = [], seats = 1\nOutput: 0\nExplanation: No representatives need to travel to the capital city.\n\n \nConstraints:\n\n1 <= n <= 105\nroads.length == n - 1\nroads[i].length == 2\n0 <= ai, bi < n\nai != bi\nroads represents a valid tree.\n1 <= seats <= 105",
    "examples": [
      {
        "input": "Input: roads = [[0,1],[0,2],[0,3]], seats = 5",
        "output": "Output: 3",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: roads = [[3,1],[3,2],[1,0],[0,4],[0,5],[4,6]], seats = 2",
        "output": "Output: 7",
        "explanation": "Explanation: "
      },
      {
        "input": "Input: roads = [], seats = 1",
        "output": "Output: 0",
        "explanation": "Explanation: No representatives need to travel to the capital city."
      }
    ],
    "topics": [
      "Tree",
      "Depth-First Search",
      "Breadth-First Search",
      "Graph"
    ],
    "difficulty": "Medium"
  },
  {
    "title": "Closest Nodes Queries in a Binary Search Tree",
    "description": "You are given the root of a binary search tree and an array queries of size n consisting of positive integers.\nFind a 2D array answer of size n where answer[i] = [mini, maxi]:\n\nmini is the largest value in the tree that is smaller than or equal to queries[i]. If a such value does not exist, add -1 instead.\nmaxi is the smallest value in the tree that is greater than or equal to queries[i]. If a such value does not exist, add -1 instead.\n\nReturn the array answer.\n \nExample 1:\n\nInput: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]\nOutput: [[2,2],[4,6],[15,-1]]\nExplanation: We answer the queries in the following way:\n- The largest number that is smaller or equal than 2 in the tree is 2, and the smallest number that is greater or equal than 2 is still 2. So the answer for the first query is [2,2].\n- The largest number that is smaller or equal than 5 in the tree is 4, and the smallest number that is greater or equal than 5 is 6. So the answer for the second query is [4,6].\n- The largest number that is smaller or equal than 16 in the tree is 15, and the smallest number that is greater or equal than 16 does not exist. So the answer for the third query is [15,-1].\n\nExample 2:\n\nInput: root = [4,null,9], queries = [3]\nOutput: [[-1,4]]\nExplanation: The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4].\n\n \nConstraints:\n\nThe number of nodes in the tree is in the range [2, 105].\n1 <= Node.val <= 106\nn == queries.length\n1 <= n <= 105\n1 <= queries[i] <= 106",
    "examples": [
      {
        "input": "Input: root = [6,2,13,1,4,9,15,null,null,null,null,null,null,14], queries = [2,5,16]",
        "output": "Output: [[2,2],[4,6],[15,-1]]",
        "explanation": "Explanation: We answer the queries in the following way:"
      },
      {
        "input": "Input: root = [4,null,9], queries = [3]",
        "output": "Output: [[-1,4]]",
        "explanation": "Explanation: The largest number that is smaller or equal to 3 in the tree does not exist, and the smallest number that is greater or equal to 3 is 4. So the answer for the query is [-1,4]."
      }
    ],
    "topics": [
      "Array",
      "Binary Search",
      "Tree",
      "Depth-First Search",
      "Binary Tree"
    ],
    "difficulty": "Medium"
  }
]