[
  {
    "title": "Power of Heroes",
    "description": "You are given a 0-indexed integer array nums representing the strength of some heroes. The power of a group of heroes is defined as follows:\n\nLet i0, i1, ... ,ik be the indices of the heroes in a group. Then, the power of this group is max(nums[i0], nums[i1], ... ,nums[ik])2 * min(nums[i0], nums[i1], ... ,nums[ik]).\n\nReturn the sum of the power of all non-empty groups of heroes possible. Since the sum could be very large, return it modulo 109 + 7.\n \nExample 1:\nInput: nums = [2,1,4]\nOutput: 141\nExplanation: \n1st group: [2] has power = 22 * 2 = 8.\n2nd group: [1] has power = 12 * 1 = 1. \n3rd group: [4] has power = 42 * 4 = 64. \n4th group: [2,1] has power = 22 * 1 = 4. \n5th group: [2,4] has power = 42 * 2 = 32. \n6th group: [1,4] has power = 42 * 1 = 16. \n​​​​​​​7th group: [2,1,4] has power = 42​​​​​​​ * 1 = 16. \nThe sum of powers of all groups is 8 + 1 + 64 + 4 + 32 + 16 + 16 = 141.\n\n\nExample 2:\nInput: nums = [1,1,1]\nOutput: 7\nExplanation: A total of 7 groups are possible, and the power of each group will be 1. Therefore, the sum of the powers of all groups is 7.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109"
  },
  {
    "title": "Make Costs of Paths Equal in a Binary Tree",
    "description": "You are given an integer n representing the number of nodes in a perfect binary tree consisting of nodes numbered from 1 to n. The root of the tree is node 1 and each node i in the tree has two children where the left child is the node 2 * i and the right child is 2 * i + 1.\nEach node in the tree also has a cost represented by a given 0-indexed integer array cost of size n where cost[i] is the cost of node i + 1. You are allowed to increment the cost of any node by 1 any number of times.\nReturn the minimum number of increments you need to make the cost of paths from the root to each leaf node equal.\nNote:\n\nA perfect binary tree is a tree where each node, except the leaf nodes, has exactly 2 children.\nThe cost of a path is the sum of costs of nodes in the path.\n\n \nExample 1:\n\nInput: n = 7, cost = [1,5,2,2,3,3,1]\nOutput: 6\nExplanation: We can do the following increments:\n- Increase the cost of node 4 one time.\n- Increase the cost of node 3 three times.\n- Increase the cost of node 7 two times.\nEach path from the root to a leaf will have a total cost of 9.\nThe total increments we did is 1 + 3 + 2 = 6.\nIt can be shown that this is the minimum answer we can achieve.\n\nExample 2:\n\nInput: n = 3, cost = [5,3,3]\nOutput: 0\nExplanation: The two paths already have equal total costs, so no increments are needed.\n\n \nConstraints:\n\n3 <= n <= 105\nn + 1 is a power of 2\ncost.length == n\n1 <= cost[i] <= 104"
  },
  {
    "title": "Number of Adjacent Elements With the Same Color",
    "description": "There is a 0-indexed array nums of length n. Initially, all elements are uncolored (has a value of 0).\nYou are given a 2D integer array queries where queries[i] = [indexi, colori].\nFor each query, you color the index indexi with the color colori in the array nums.\nReturn an array answer of the same length as queries where answer[i] is the number of adjacent elements with the same color after the ith query.\nMore formally, answer[i] is the number of indices j, such that 0 <= j < n - 1 and nums[j] == nums[j + 1] and nums[j] != 0 after the ith query.\n \nExample 1:\nInput: n = 4, queries = [[0,2],[1,2],[3,1],[1,1],[2,1]]\nOutput: [0,1,1,0,2]\nExplanation: Initially array nums = [0,0,0,0], where 0 denotes uncolored elements of the array.\n- After the 1st query nums = [2,0,0,0]. The count of adjacent elements with the same color is 0.\n- After the 2nd query nums = [2,2,0,0]. The count of adjacent elements with the same color is 1.\n- After the 3rd query nums = [2,2,0,1]. The count of adjacent elements with the same color is 1.\n- After the 4th query nums = [2,1,0,1]. The count of adjacent elements with the same color is 0.\n- After the 5th query nums = [2,1,1,1]. The count of adjacent elements with the same color is 2.\n\nExample 2:\nInput: n = 1, queries = [[0,100000]]\nOutput: [0]\nExplanation: Initially array nums = [0], where 0 denotes uncolored elements of the array.\n- After the 1st query nums = [100000]. The count of adjacent elements with the same color is 0.\n\n \nConstraints:\n\n1 <= n <= 105\n1 <= queries.length <= 105\nqueries[i].length == 2\n0 <= indexi <= n - 1\n1 <=  colori <= 105"
  },
  {
    "title": "Frequency Tracker",
    "description": "Design a data structure that keeps track of the values in it and answers some queries regarding their frequencies.\nImplement the FrequencyTracker class.\n\nFrequencyTracker(): Initializes the FrequencyTracker object with an empty array initially.\nvoid add(int number): Adds number to the data structure.\nvoid deleteOne(int number): Deletes one occurence of number from the data structure. The data structure may not contain number, and in this case nothing is deleted.\nbool hasFrequency(int frequency): Returns true if there is a number in the data structure that occurs frequency number of times, otherwise, it returns false.\n\n \nExample 1:\nInput\n[\"FrequencyTracker\", \"add\", \"add\", \"hasFrequency\"]\n[[], [3], [3], [2]]\nOutput\n[null, null, null, true]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.add(3); // The data structure now contains [3, 3]\nfrequencyTracker.hasFrequency(2); // Returns true, because 3 occurs twice\n\n\nExample 2:\nInput\n[\"FrequencyTracker\", \"add\", \"deleteOne\", \"hasFrequency\"]\n[[], [1], [1], [1]]\nOutput\n[null, null, null, false]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.add(1); // The data structure now contains [1]\nfrequencyTracker.deleteOne(1); // The data structure becomes empty []\nfrequencyTracker.hasFrequency(1); // Returns false, because the data structure is empty\n\n\nExample 3:\nInput\n[\"FrequencyTracker\", \"hasFrequency\", \"add\", \"hasFrequency\"]\n[[], [2], [3], [1]]\nOutput\n[null, false, null, true]\n\nExplanation\nFrequencyTracker frequencyTracker = new FrequencyTracker();\nfrequencyTracker.hasFrequency(2); // Returns false, because the data structure is empty\nfrequencyTracker.add(3); // The data structure now contains [3]\nfrequencyTracker.hasFrequency(1); // Returns true, because 3 occurs once\n\n\n \nConstraints:\n\n1 <= number <= 105\n1 <= frequency <= 105\nAt most, 2 * 105 calls will be made to add, deleteOne, and hasFrequency in total."
  },
  {
    "title": "Find the Distinct Difference Array",
    "description": "You are given a 0-indexed array nums of length n.\nThe distinct difference array of nums is an array diff of length n such that diff[i] is equal to the number of distinct elements in the suffix nums[i + 1, ..., n - 1] subtracted from the number of distinct elements in the prefix nums[0, ..., i].\nReturn the distinct difference array of nums.\nNote that nums[i, ..., j] denotes the subarray of nums starting at index i and ending at index j inclusive. Particularly, if i > j then nums[i, ..., j] denotes an empty subarray.\n \nExample 1:\nInput: nums = [1,2,3,4,5]\nOutput: [-3,-1,1,3,5]\nExplanation: For index i = 0, there is 1 element in the prefix and 4 distinct elements in the suffix. Thus, diff[0] = 1 - 4 = -3.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 3 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 3 - 2 = 1.\nFor index i = 3, there are 4 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 4 - 1 = 3.\nFor index i = 4, there are 5 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 5 - 0 = 5.\n\nExample 2:\nInput: nums = [3,2,3,4,2]\nOutput: [-2,-1,0,2,3]\nExplanation: For index i = 0, there is 1 element in the prefix and 3 distinct elements in the suffix. Thus, diff[0] = 1 - 3 = -2.\nFor index i = 1, there are 2 distinct elements in the prefix and 3 distinct elements in the suffix. Thus, diff[1] = 2 - 3 = -1.\nFor index i = 2, there are 2 distinct elements in the prefix and 2 distinct elements in the suffix. Thus, diff[2] = 2 - 2 = 0.\nFor index i = 3, there are 3 distinct elements in the prefix and 1 distinct element in the suffix. Thus, diff[3] = 3 - 1 = 2.\nFor index i = 4, there are 3 distinct elements in the prefix and no elements in the suffix. Thus, diff[4] = 3 - 0 = 3.\n\n \nConstraints:\n\n1 <= n == nums.length <= 50\n1 <= nums[i] <= 50"
  },
  {
    "title": "Maximum Sum With Exactly K Elements ",
    "description": "You are given a 0-indexed integer array nums and an integer k. Your task is to perform the following operation exactly k times in order to maximize your score:\n\nSelect an element m from nums.\nRemove the selected element m from the array.\nAdd a new element with a value of m + 1 to the array.\nIncrease your score by m.\n\nReturn the maximum score you can achieve after performing the operation exactly k times.\n \nExample 1:\nInput: nums = [1,2,3,4,5], k = 3\nOutput: 18\nExplanation: We need to choose exactly 3 elements from nums to maximize the sum.\nFor the first iteration, we choose 5. Then sum is 5 and nums = [1,2,3,4,6]\nFor the second iteration, we choose 6. Then sum is 5 + 6 and nums = [1,2,3,4,7]\nFor the third iteration, we choose 7. Then sum is 5 + 6 + 7 = 18 and nums = [1,2,3,4,8]\nSo, we will return 18.\nIt can be proven, that 18 is the maximum answer that we can achieve.\n\nExample 2:\nInput: nums = [5,5,5], k = 2\nOutput: 11\nExplanation: We need to choose exactly 2 elements from nums to maximize the sum.\nFor the first iteration, we choose 5. Then sum is 5 and nums = [5,5,6]\nFor the second iteration, we choose 6. Then sum is 5 + 6 = 11 and nums = [5,5,7]\nSo, we will return 11.\nIt can be proven, that 11 is the maximum answer that we can achieve.\n\n \nConstraints:\n\n1 <= nums.length <= 100\n1 <= nums[i] <= 100\n1 <= k <= 100"
  },
  {
    "title": "Find the Prefix Common Array of Two Arrays",
    "description": "You are given two 0-indexed integer permutations A and B of length n.\nA prefix common array of A and B is an array C such that C[i] is equal to the count of numbers that are present at or before the index i in both A and B.\nReturn the prefix common array of A and B.\nA sequence of n integers is called a permutation if it contains all integers from 1 to n exactly once.\n \nExample 1:\nInput: A = [1,3,2,4], B = [3,1,2,4]\nOutput: [0,2,3,4]\nExplanation: At i = 0: no number is common, so C[0] = 0.\nAt i = 1: 1 and 3 are common in A and B, so C[1] = 2.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\nAt i = 3: 1, 2, 3, and 4 are common in A and B, so C[3] = 4.\n\nExample 2:\nInput: A = [2,3,1], B = [3,1,2]\nOutput: [0,1,3]\nExplanation: At i = 0: no number is common, so C[0] = 0.\nAt i = 1: only 3 is common in A and B, so C[1] = 1.\nAt i = 2: 1, 2, and 3 are common in A and B, so C[2] = 3.\n\n \nConstraints:\n\n1 <= A.length == B.length == n <= 50\n1 <= A[i], B[i] <= n\nIt is guaranteed that A and B are both a permutation of n integers."
  },
  {
    "title": "Make Array Empty",
    "description": "You are given an integer array nums containing distinct numbers, and you can perform the following operations until the array is empty:\n\nIf the first element has the smallest value, remove it\nOtherwise, put the first element at the end of the array.\n\nReturn an integer denoting the number of operations it takes to make nums empty.\n \nExample 1:\nInput: nums = [3,4,-1]\nOutput: 5\n\nOperationArray1[4, -1, 3]2[-1, 3, 4]3[3, 4]4[4]5[]\nExample 2:\nInput: nums = [1,2,4,3]\nOutput: 5\n\nOperationArray1[2, 4, 3]2[4, 3]3[3, 4]4[4]5[]\nExample 3:\nInput: nums = [1,2,3]\nOutput: 3\n\nOperationArray1[2, 3]2[3]3[]\n \nConstraints:\n\n1 <= nums.length <= 105\n-109 <= nums[i] <= 109\nAll values in nums are distinct."
  },
  {
    "title": "Maximum Number of Fish in a Grid",
    "description": "You are given a 0-indexed 2D matrix grid of size m x n, where (r, c) represents:\n\nA land cell if grid[r][c] = 0, or\nA water cell containing grid[r][c] fish, if grid[r][c] > 0.\n\nA fisher can start at any water cell (r, c) and can do the following operations any number of times:\n\nCatch all the fish at cell (r, c), or\nMove to any adjacent water cell.\n\nReturn the maximum number of fish the fisher can catch if he chooses his starting cell optimally, or 0 if no water cell exists.\nAn adjacent cell of the cell (r, c), is one of the cells (r, c + 1), (r, c - 1), (r + 1, c) or (r - 1, c) if it exists.\n \nExample 1:\n\nInput: grid = [[0,2,1,0],[4,0,0,3],[1,0,0,4],[0,3,2,0]]\nOutput: 7\nExplanation: The fisher can start at cell (1,3) and collect 3 fish, then move to cell (2,3) and collect 4 fish.\n\nExample 2:\n\nInput: grid = [[1,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,1]]\nOutput: 1\nExplanation: The fisher can start at cells (0,0) or (3,3) and collect a single fish. \n\n \nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 10\n0 <= grid[i][j] <= 10"
  },
  {
    "title": "Minimum Number of Operations to Make All Array Elements Equal to 1",
    "description": "You are given a 0-indexed array nums consisiting of positive integers. You can do the following operation on the array any number of times:\n\nSelect an index i such that 0 <= i < n - 1 and replace either of nums[i] or nums[i+1] with their gcd value.\n\nReturn the minimum number of operations to make all elements of nums equal to 1. If it is impossible, return -1.\nThe gcd of two integers is the greatest common divisor of the two integers.\n \nExample 1:\nInput: nums = [2,6,3,4]\nOutput: 4\nExplanation: We can do the following operations:\n- Choose index i = 2 and replace nums[2] with gcd(3,4) = 1. Now we have nums = [2,6,1,4].\n- Choose index i = 1 and replace nums[1] with gcd(6,1) = 1. Now we have nums = [2,1,1,4].\n- Choose index i = 0 and replace nums[0] with gcd(2,1) = 1. Now we have nums = [1,1,1,4].\n- Choose index i = 2 and replace nums[3] with gcd(1,4) = 1. Now we have nums = [1,1,1,1].\n\nExample 2:\nInput: nums = [2,10,6,14]\nOutput: -1\nExplanation: It can be shown that it is impossible to make all the elements equal to 1.\n\n \nConstraints:\n\n2 <= nums.length <= 50\n1 <= nums[i] <= 106\n\n \nFollow-up:\nThe O(n) time complexity solution works, but could you find an O(1) constant time complexity solution?"
  },
  {
    "title": "Sum Multiples",
    "description": "Given a positive integer n, find the sum of all integers in the range [1, n] inclusive that are divisible by 3, 5, or 7.\nReturn an integer denoting the sum of all numbers in the given range satisfying the constraint.\n \nExample 1:\nInput: n = 7\nOutput: 21\nExplanation: Numbers in the range [1, 7] that are divisible by 3, 5, or 7 are 3, 5, 6, 7. The sum of these numbers is 21.\n\nExample 2:\nInput: n = 10\nOutput: 40\nExplanation: Numbers in the range [1, 10] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9, 10. The sum of these numbers is 40.\n\nExample 3:\nInput: n = 9\nOutput: 30\nExplanation: Numbers in the range [1, 9] that are divisible by 3, 5, or 7 are 3, 5, 6, 7, 9. The sum of these numbers is 30.\n\n \nConstraints:\n\n1 <= n <= 103"
  },
  {
    "title": "Sliding Subarray Beauty",
    "description": "Given an integer array nums containing n integers, find the beauty of each subarray of size k.\nThe beauty of a subarray is the xth smallest integer in the subarray if it is negative, or 0 if there are fewer than x negative integers.\nReturn an integer array containing n - k + 1 integers, which denote the beauty of the subarrays in order from the first index in the array.\n\n\nA subarray is a contiguous non-empty sequence of elements within an array.\n\n\n \nExample 1:\nInput: nums = [1,-1,-3,-2,3], k = 3, x = 2\nOutput: [-1,-2,-2]\nExplanation: There are 3 subarrays with size k = 3. \nThe first subarray is [1, -1, -3] and the 2nd smallest negative integer is -1. \nThe second subarray is [-1, -3, -2] and the 2nd smallest negative integer is -2. \nThe third subarray is [-3, -2, 3] and the 2nd smallest negative integer is -2.\nExample 2:\nInput: nums = [-1,-2,-3,-4,-5], k = 2, x = 2\nOutput: [-1,-2,-3,-4]\nExplanation: There are 4 subarrays with size k = 2.\nFor [-1, -2], the 2nd smallest negative integer is -1.\nFor [-2, -3], the 2nd smallest negative integer is -2.\nFor [-3, -4], the 2nd smallest negative integer is -3.\nFor [-4, -5], the 2nd smallest negative integer is -4. \nExample 3:\nInput: nums = [-3,1,2,-3,0,-3], k = 2, x = 1\nOutput: [-3,0,-3,-3,-3]\nExplanation: There are 5 subarrays with size k = 2.\nFor [-3, 1], the 1st smallest negative integer is -3.\nFor [1, 2], there is no negative integer so the beauty is 0.\nFor [2, -3], the 1st smallest negative integer is -3.\nFor [-3, 0], the 1st smallest negative integer is -3.\nFor [0, -3], the 1st smallest negative integer is -3.\n \nConstraints:\n\nn == nums.length \n1 <= n <= 105\n1 <= k <= n\n1 <= x <= k \n-50 <= nums[i] <= 50"
  },
  {
    "title": "Calculate Delayed Arrival Time",
    "description": "You are given a positive integer arrivalTime denoting the arrival time of a train in hours, and another positive integer delayedTime denoting the amount of delay in hours.\nReturn the time when the train will arrive at the station.\nNote that the time in this problem is in 24-hours format.\n \nExample 1:\nInput: arrivalTime = 15, delayedTime = 5 \nOutput: 20 \nExplanation: Arrival time of the train was 15:00 hours. It is delayed by 5 hours. Now it will reach at 15+5 = 20 (20:00 hours).\n\nExample 2:\nInput: arrivalTime = 13, delayedTime = 11\nOutput: 0\nExplanation: Arrival time of the train was 13:00 hours. It is delayed by 11 hours. Now it will reach at 13+11=24 (Which is denoted by 00:00 in 24 hours format so return 0).\n\n \nConstraints:\n\n1 <= arrivaltime < 24\n1 <= delayedTime <= 24"
  },
  {
    "title": "Minimize the Total Price of the Trips",
    "description": "There exists an undirected and unrooted tree with n nodes indexed from 0 to n - 1. You are given the integer n and a 2D integer array edges of length n - 1, where edges[i] = [ai, bi] indicates that there is an edge between nodes ai and bi in the tree.\nEach node has an associated price. You are given an integer array price, where price[i] is the price of the ith node.\nThe price sum of a given path is the sum of the prices of all nodes lying on that path.\nAdditionally, you are given a 2D integer array trips, where trips[i] = [starti, endi] indicates that you start the ith trip from the node starti and travel to the node endi by any path you like.\nBefore performing your first trip, you can choose some non-adjacent nodes and halve the prices.\nReturn the minimum total price sum to perform all the given trips.\n \nExample 1:\n\nInput: n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]\nOutput: 23\nExplanation: The diagram above denotes the tree after rooting it at node 2. The first part shows the initial tree and the second part shows the tree after choosing nodes 0, 2, and 3, and making their price half.\nFor the 1st trip, we choose path [0,1,3]. The price sum of that path is 1 + 2 + 3 = 6.\nFor the 2nd trip, we choose path [2,1]. The price sum of that path is 2 + 5 = 7.\nFor the 3rd trip, we choose path [2,1,3]. The price sum of that path is 5 + 2 + 3 = 10.\nThe total price sum of all trips is 6 + 7 + 10 = 23.\nIt can be proven, that 23 is the minimum answer that we can achieve.\n\nExample 2:\n\nInput: n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]\nOutput: 1\nExplanation: The diagram above denotes the tree after rooting it at node 0. The first part shows the initial tree and the second part shows the tree after choosing node 0, and making its price half.\nFor the 1st trip, we choose path [0]. The price sum of that path is 1.\nThe total price sum of all trips is 1. It can be proven, that 1 is the minimum answer that we can achieve.\n\n \nConstraints:\n\n1 <= n <= 50\nedges.length == n - 1\n0 <= ai, bi <= n - 1\nedges represents a valid tree.\nprice.length == n\nprice[i] is an even integer.\n1 <= price[i] <= 1000\n1 <= trips.length <= 100\n0 <= starti, endi <= n - 1"
  },
  {
    "title": "Row With Maximum Ones",
    "description": "Given a m x n binary matrix mat, find the 0-indexed position of the row that contains the maximum count of ones, and the number of ones in that row.\nIn case there are multiple rows that have the maximum count of ones, the row with the smallest row number should be selected.\nReturn an array containing the index of the row, and the number of ones in it.\n \nExample 1:\nInput: mat = [[0,1],[1,0]]\nOutput: [0,1]\nExplanation: Both rows have the same number of 1's. So we return the index of the smaller row, 0, and the maximum count of ones (1). So, the answer is [0,1]. \n\nExample 2:\nInput: mat = [[0,0,0],[0,1,1]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So we return its index, 1, and the count. So, the answer is [1,2].\n\nExample 3:\nInput: mat = [[0,0],[1,1],[0,0]]\nOutput: [1,2]\nExplanation: The row indexed 1 has the maximum count of ones (2). So the answer is [1,2].\n\n \nConstraints:\n\nm == mat.length \nn == mat[i].length \n1 <= m, n <= 100 \nmat[i][j] is either 0 or 1."
  },
  {
    "title": "Minimum Additions to Make Valid String",
    "description": "Given a string word to which you can insert letters \"a\", \"b\" or \"c\" anywhere and any number of times, return the minimum number of letters that must be inserted so that word becomes valid.\nA string is called valid if it can be formed by concatenating the string \"abc\" several times.\n \nExample 1:\nInput: word = \"b\"\nOutput: 2\nExplanation: Insert the letter \"a\" right before \"b\", and the letter \"c\" right next to \"a\" to obtain the valid string \"abc\".\n\nExample 2:\nInput: word = \"aaa\"\nOutput: 6\nExplanation: Insert letters \"b\" and \"c\" next to each \"a\" to obtain the valid string \"abcabcabc\".\n\nExample 3:\nInput: word = \"abc\"\nOutput: 0\nExplanation: word is already valid. No modifications are needed. \n\n \nConstraints:\n\n1 <= word.length <= 50\nword consists of letters \"a\", \"b\" and \"c\" only."
  },
  {
    "title": "Maximum OR",
    "description": "You are given a 0-indexed integer array nums of length n and an integer k. In an operation, you can choose an element and multiply it by 2.\nReturn the maximum possible value of nums[0] | nums[1] | ... | nums[n - 1] that can be obtained after applying the operation on nums at most k times.\nNote that a | b denotes the bitwise or between two integers a and b.\n \nExample 1:\nInput: nums = [12,9], k = 1\nOutput: 30\nExplanation: If we apply the operation to index 1, our new array nums will be equal to [12,18]. Thus, we return the bitwise or of 12 and 18, which is 30.\n\nExample 2:\nInput: nums = [8,1,2], k = 2\nOutput: 35\nExplanation: If we apply the operation twice on index 0, we yield a new array of [32,1,2]. Thus, we return 32|1|2 = 35.\n\n \nConstraints:\n\n1 <= nums.length <= 105\n1 <= nums[i] <= 109\n1 <= k <= 15"
  },
  {
    "title": "Sum in a Matrix",
    "description": "You are given a 0-indexed 2D integer array nums. Initially, your score is 0. Perform the following operations until the matrix becomes empty:\n\nFrom each row in the matrix, select the largest number and remove it. In the case of a tie, it does not matter which number is chosen.\nIdentify the highest number amongst all those removed in step 1. Add that number to your score.\n\nReturn the final score.\n \nExample 1:\nInput: nums = [[7,2,1],[6,4,2],[6,5,3],[3,2,1]]\nOutput: 15\nExplanation: In the first operation, we remove 7, 6, 6, and 3. We then add 7 to our score. Next, we remove 2, 4, 5, and 2. We add 5 to our score. Lastly, we remove 1, 2, 3, and 1. We add 3 to our score. Thus, our final score is 7 + 5 + 3 = 15.\n\nExample 2:\nInput: nums = [[1]]\nOutput: 1\nExplanation: We remove 1 and add it to the answer. We return 1.\n \nConstraints:\n\n1 <= nums.length <= 300\n1 <= nums[i].length <= 500\n0 <= nums[i][j] <= 103"
  },
  {
    "title": "Number of Senior Citizens",
    "description": "You are given a 0-indexed array of strings details. Each element of details provides information about a given passenger compressed into a string of length 15. The system is such that:\n\nThe first ten characters consist of the phone number of passengers.\nThe next character denotes the gender of the person.\nThe following two characters are used to indicate the age of the person.\nThe last two characters determine the seat allotted to that person.\n\nReturn the number of passengers who are strictly more than 60 years old.\n \nExample 1:\nInput: details = [\"7868190130M7522\",\"5303914400F9211\",\"9273338290F4010\"]\nOutput: 2\nExplanation: The passengers at indices 0, 1, and 2 have ages 75, 92, and 40. Thus, there are 2 people who are over 60 years old.\n\nExample 2:\nInput: details = [\"1313579440F2036\",\"2921522980M5644\"]\nOutput: 0\nExplanation: None of the passengers are older than 60.\n\n \nConstraints:\n\n1 <= details.length <= 100\ndetails[i].length == 15\ndetails[i] consists of digits from '0' to '9'.\ndetails[i][10] is either 'M' or 'F' or 'O'.\nThe phone numbers and seat numbers of the passengers are distinct."
  },
  {
    "title": "Minimum Reverse Operations",
    "description": "You are given an integer n and an integer p in the range [0, n - 1]. Representing a 0-indexed array arr of length n where all positions are set to 0's, except position p which is set to 1.\nYou are also given an integer array banned containing some positions from the array. For the ith position in banned, arr[banned[i]] = 0, and banned[i] != p.\nYou can perform multiple operations on arr. In an operation, you can choose a subarray with size k and reverse the subarray. However, the 1 in arr should never go to any of the positions in banned. In other words, after each operation arr[banned[i]] remains 0.\nReturn an array ans where for each i from [0, n - 1], ans[i] is the minimum number of reverse operations needed to bring the 1 to position i in arr, or -1 if it is impossible.\n\nA subarray is a contiguous non-empty sequence of elements within an array.\nThe values of ans[i] are independent for all i's.\nThe reverse of an array is an array containing the values in reverse order.\n\n \nExample 1:\nInput: n = 4, p = 0, banned = [1,2], k = 4\nOutput: [0,-1,-1,1]\nExplanation: In this case k = 4 so there is only one possible reverse operation we can perform, which is reversing the whole array. Initially, 1 is placed at position 0 so the amount of operations we need for position 0 is 0. We can never place a 1 on the banned positions, so the answer for positions 1 and 2 is -1. Finally, with one reverse operation we can bring the 1 to index 3, so the answer for position 3 is 1. \n\nExample 2:\nInput: n = 5, p = 0, banned = [2,4], k = 3\nOutput: [0,-1,-1,-1,-1]\nExplanation: In this case the 1 is initially at position 0, so the answer for that position is 0. We can perform reverse operations of size 3. The 1 is currently located at position 0, so we need to reverse the subarray [0, 2] for it to leave that position, but reversing that subarray makes position 2 have a 1, which shouldn't happen. So, we can't move the 1 from position 0, making the result for all the other positions -1. \n\nExample 3:\nInput: n = 4, p = 2, banned = [0,1,3], k = 1\nOutput: [-1,-1,0,-1]\nExplanation: In this case we can only perform reverse operations of size 1. So the 1 never changes its position.\n\n \nConstraints:\n\n1 <= n <= 105\n0 <= p <= n - 1\n0 <= banned.length <= n - 1\n0 <= banned[i] <= n - 1\n1 <= k <= n \nbanned[i] != p\nall values in banned are unique"
  }
]